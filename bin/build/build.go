package main

import (
	"bufio"
	"bytes"
	"context"
	"fmt"
	"io"
	"io/fs"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
)

func main() {
	ctx := context.Background()
	ctx, cancel := context.WithTimeout(ctx, 10*time.Minute)
	defer cancel()

	repo, err := os.OpenRoot(repoRoot(ctx))
	must(err)
	log.Printf("cd'ing to repo root: %v", repo.Name())
	must(os.Chdir(repo.Name()))

	mustRun(exec.CommandContext(ctx, "go", "tool", "sqlc", "generate"))
	mustRun(exec.CommandContext(ctx, "go", "tool", "templ", "generate"))
	mustRun(exec.CommandContext(ctx, "go", "tool", "tsgo"))
	// We presume that all of these JS files were generated from TypeScript, as
	// that's currently the case. `tsc` had a `--listEmittedFiles` flag that would
	// aid here, but `tsgo` doesn't yet have that feature.
	jsFiles, err := fs.Glob(repo.FS(), filepath.Join("web", "static", "*.js"))
	for _, match := range jsFiles {
		addTSGeneratedHeader(repo, match)
	}
	mustRun(exec.CommandContext(ctx, "go", "run", filepath.Join("bin", "fetchclientdeps", "fetchclientdeps.go")))
	mustRun(exec.CommandContext(ctx, "go", "build"))
	log.Println("All done! You can now run ./ranger-ims-go")
}

func addTSGeneratedHeader(repo *os.Root, filename string) {
	// Read in the current version of the file.
	f, err := repo.Open(filename)
	must(err)
	contents, err := io.ReadAll(f)
	must(err)
	must(f.Close())

	// Re-open and truncate the file.
	f, err = repo.Create(filename)
	must(err)

	// Write the header, then the original file contents.
	_, err = f.WriteString("// Code generated by tsgo. DO NOT EDIT.\n\n")
	must(err)
	scanner := bufio.NewScanner(bytes.NewReader(contents))
	for scanner.Scan() {
		_, err = f.WriteString(scanner.Text())
		must(err)
		_, err = f.WriteString("\n")
		must(err)
	}
	must(f.Close())
}

func mustRun(cmd *exec.Cmd) {
	log.Printf("`%v`: running", strings.Join(cmd.Args, " "))
	output, err := cmd.CombinedOutput()
	if err != nil {
		log.Printf("`%v`: failed!", strings.Join(cmd.Args, " "))
		must(err)
		log.Printf("failed command output:\n%v", string(output))
	}
	log.Printf("`%v`: succeeded", strings.Join(cmd.Args, " "))
}

func repoRoot(ctx context.Context) string {
	// The GOMOD variable gives an absolute path to go.mod, which we use to find
	// the repo root directory
	cmd := exec.CommandContext(ctx, "go", "env", "GOMOD")
	goModPathBytes, err := cmd.CombinedOutput()
	must(err)
	repoRoot := filepath.Dir(strings.TrimSpace(string(goModPathBytes)))
	if !pathExists(os.Stat(repoRoot)) {
		must(fmt.Errorf("repo root %v does not exist", repoRoot))
	}
	return repoRoot
}

func pathExists(_ os.FileInfo, err error) bool {
	return !os.IsNotExist(err)
}

func must(err error) {
	if err != nil {
		log.Fatal(err)
	}
}
