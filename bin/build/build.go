//
// See the file COPYRIGHT for copyright information.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package main

import (
	"bufio"
	"bytes"
	"context"
	"fmt"
	"golang.org/x/sync/errgroup"
	"io/fs"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"time"
)

func main() {
	start := time.Now()
	ctx := context.Background()
	ctx, cancel := context.WithTimeout(ctx, 10*time.Minute)
	defer cancel()

	repo, err := os.OpenRoot(repoRoot(ctx))
	must(err)

	eg, gCtx := errgroup.WithContext(ctx)
	eg.Go(func() error {
		mustRunInDir(exec.CommandContext(gCtx, "go", "tool", "sqlc", "generate"), repo.Name())
		return nil
	})
	eg.Go(func() error {
		mustRunInDir(exec.CommandContext(gCtx, "go", "tool", "templ", "generate"), repo.Name())
		return nil
	})
	eg.Go(func() error {
		mustRunInDir(exec.CommandContext(gCtx, "go", "tool", "tsgo"), repo.Name())
		// We presume that all of these JS files were generated from TypeScript, as
		// that's currently the case. `tsc` had a `--listEmittedFiles` flag that would
		// aid here, but `tsgo` doesn't yet have that feature.
		jsFiles, err := fs.Glob(repo.FS(), filepath.Join("web", "static", "*.js"))
		must(err)
		for _, match := range jsFiles {
			addTSGeneratedHeader(repo, match)
		}
		return nil
	})
	eg.Go(func() error {
		mustRunInDir(
			exec.CommandContext(gCtx, "go", "run", "fetchbuilddeps.go"),
			filepath.Join(repo.Name(), "bin", "fetchbuilddeps"),
		)
		return nil
	})
	must(eg.Wait())

	mustRunInDir(exec.CommandContext(ctx, "go", "build"), repo.Name())
	log.Printf("All done in %v. You can now run ./ranger-ims-go", time.Since(start))
}

func addTSGeneratedHeader(repo *os.Root, filename string) {
	// Read in the current version of the file.
	contents, err := repo.ReadFile(filename)
	must(err)

	// Re-open and truncate the file.
	f, err := repo.Create(filename)
	must(err)

	// WriteResponse the header, then the original file contents.
	_, err = f.WriteString("// Code generated by tsgo. DO NOT EDIT.\n\n")
	must(err)
	scanner := bufio.NewScanner(bytes.NewReader(contents))
	for scanner.Scan() {
		_, err = f.WriteString(scanner.Text())
		must(err)
		_, err = f.WriteString("\n")
		must(err)
	}
	must(f.Close())
}

func mustRunInDir(cmd *exec.Cmd, dir string) {
	start := time.Now()
	cmd.Dir = dir
	log.Printf("`%v`: running in %v", strings.Join(cmd.Args, " "), dir)
	output, err := cmd.CombinedOutput()
	if err != nil {
		log.Printf("`%v`: failed!", strings.Join(cmd.Args, " "))
		log.Printf("failed command output:\n%v", string(output))
		must(err)
	}
	log.Printf("`%v`: succeeded in %v", strings.Join(cmd.Args, " "), time.Since(start))
}

func repoRoot(ctx context.Context) string {
	// The GOMOD variable gives an absolute path to go.mod, which we use to find
	// the repo root directory
	cmd := exec.CommandContext(ctx, "go", "env", "GOMOD")
	goModPathBytes, err := cmd.CombinedOutput()
	must(err)
	repoRoot := filepath.Dir(strings.TrimSpace(string(goModPathBytes)))
	if !pathExists(os.Stat(repoRoot)) {
		must(fmt.Errorf("repo root %v does not exist", repoRoot))
	}
	return repoRoot
}

func pathExists(_ os.FileInfo, err error) bool {
	return !os.IsNotExist(err)
}

func must(err error) {
	if err != nil {
		log.Fatal(err)
	}
}
