// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package clubhousedb

import (
	"context"
	"database/sql"
)

const personPositions = `-- name: PersonPositions :many
select person_id, position_id from person_position
`

func (q *Queries) PersonPositions(ctx context.Context, db DBTX) ([]PersonPosition, error) {
	rows, err := db.QueryContext(ctx, personPositions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PersonPosition
	for rows.Next() {
		var i PersonPosition
		if err := rows.Scan(&i.PersonID, &i.PositionID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const personTeams = `-- name: PersonTeams :many
select person_id, team_id from person_team
`

type PersonTeamsRow struct {
	PersonID int64
	TeamID   int64
}

func (q *Queries) PersonTeams(ctx context.Context, db DBTX) ([]PersonTeamsRow, error) {
	rows, err := db.QueryContext(ctx, personTeams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PersonTeamsRow
	for rows.Next() {
		var i PersonTeamsRow
		if err := rows.Scan(&i.PersonID, &i.TeamID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const persons = `-- name: Persons :many
select
    id,
    callsign,
    email,
    status,
    on_site,
    password
from person
where status in ('active', 'inactive', 'inactive extension', 'auditor', 'prospective', 'alpha')
`

type PersonsRow struct {
	ID       int64
	Callsign string
	Email    sql.NullString
	Status   PersonStatus
	OnSite   bool
	Password sql.NullString
}

// Filter persons to those with statuses that may be of interest to IMS.
// These Persons results are used to determine who may log into IMS, and also
// to determine who shows up in the Incident page's "Add Ranger" section.
//
// This intentionally excludes statuses like bonked, echelon, deceased, resigned, and retired,
// as those persons should not be able to log into IMS nor be granted any permissions in IMS.
func (q *Queries) Persons(ctx context.Context, db DBTX) ([]PersonsRow, error) {
	rows, err := db.QueryContext(ctx, persons)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PersonsRow
	for rows.Next() {
		var i PersonsRow
		if err := rows.Scan(
			&i.ID,
			&i.Callsign,
			&i.Email,
			&i.Status,
			&i.OnSite,
			&i.Password,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const personsOnDuty = `-- name: PersonsOnDuty :many
select
    person_id,
    position_id
from
    timesheet
where
    on_duty > date_sub(now(), interval 60 day)
    and off_duty is null
`

type PersonsOnDutyRow struct {
	PersonID   uint64
	PositionID uint64
}

func (q *Queries) PersonsOnDuty(ctx context.Context, db DBTX) ([]PersonsOnDutyRow, error) {
	rows, err := db.QueryContext(ctx, personsOnDuty)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PersonsOnDutyRow
	for rows.Next() {
		var i PersonsOnDutyRow
		if err := rows.Scan(&i.PersonID, &i.PositionID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const positions = `-- name: Positions :many
select id, title from position where all_rangers = 0
`

type PositionsRow struct {
	ID    int64
	Title string
}

func (q *Queries) Positions(ctx context.Context, db DBTX) ([]PositionsRow, error) {
	rows, err := db.QueryContext(ctx, positions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PositionsRow
	for rows.Next() {
		var i PositionsRow
		if err := rows.Scan(&i.ID, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const teams = `-- name: Teams :many
select id, title from team where active
`

type TeamsRow struct {
	ID    int64
	Title string
}

func (q *Queries) Teams(ctx context.Context, db DBTX) ([]TeamsRow, error) {
	rows, err := db.QueryContext(ctx, teams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TeamsRow
	for rows.Next() {
		var i TeamsRow
		if err := rows.Scan(&i.ID, &i.Title); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
