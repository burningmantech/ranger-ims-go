// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package imsdb

import (
	"context"
	"database/sql"
	"encoding/json"
)

const actionLogs = `-- name: ActionLogs :many
select
    al.id, al.created_at, al.action_type, al.method, al.path, al.referrer, al.user_id, al.user_name, al.position_id, al.position_name, al.client_address, al.http_status, al.duration_micros
from
    ACTION_LOG al
where
    al.CREATED_AT > ?
    and al.CREATED_AT < ?
`

type ActionLogsParams struct {
	MinTime float64
	MaxTime float64
}

type ActionLogsRow struct {
	ActionLog ActionLog
}

func (q *Queries) ActionLogs(ctx context.Context, db DBTX, arg ActionLogsParams) ([]ActionLogsRow, error) {
	rows, err := db.QueryContext(ctx, actionLogs, arg.MinTime, arg.MaxTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ActionLogsRow
	for rows.Next() {
		var i ActionLogsRow
		if err := rows.Scan(
			&i.ActionLog.ID,
			&i.ActionLog.CreatedAt,
			&i.ActionLog.ActionType,
			&i.ActionLog.Method,
			&i.ActionLog.Path,
			&i.ActionLog.Referrer,
			&i.ActionLog.UserID,
			&i.ActionLog.UserName,
			&i.ActionLog.PositionID,
			&i.ActionLog.PositionName,
			&i.ActionLog.ClientAddress,
			&i.ActionLog.HttpStatus,
			&i.ActionLog.DurationMicros,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const addActionLog = `-- name: AddActionLog :execlastid
insert into ACTION_LOG
    (CREATED_AT, ACTION_TYPE, METHOD, PATH, REFERRER, USER_ID, USER_NAME, POSITION_ID, POSITION_NAME, CLIENT_ADDRESS, HTTP_STATUS, DURATION_MICROS)
values
    (?,?,?,?,?,?,?,?,?,?,?,?)
`

type AddActionLogParams struct {
	CreatedAt      float64
	ActionType     string
	Method         sql.NullString
	Path           sql.NullString
	Referrer       sql.NullString
	UserID         sql.NullInt64
	UserName       sql.NullString
	PositionID     sql.NullInt64
	PositionName   sql.NullString
	ClientAddress  sql.NullString
	HttpStatus     sql.NullInt16
	DurationMicros sql.NullInt64
}

func (q *Queries) AddActionLog(ctx context.Context, db DBTX, arg AddActionLogParams) (int64, error) {
	result, err := db.ExecContext(ctx, addActionLog,
		arg.CreatedAt,
		arg.ActionType,
		arg.Method,
		arg.Path,
		arg.Referrer,
		arg.UserID,
		arg.UserName,
		arg.PositionID,
		arg.PositionName,
		arg.ClientAddress,
		arg.HttpStatus,
		arg.DurationMicros,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const addEventAccess = `-- name: AddEventAccess :execlastid
insert into EVENT_ACCESS (EVENT, EXPRESSION, MODE, VALIDITY, EXPIRES)
values (?, ?, ?, ?, ?)
`

type AddEventAccessParams struct {
	Event      int32
	Expression string
	Mode       EventAccessMode
	Validity   EventAccessValidity
	Expires    sql.NullFloat64
}

func (q *Queries) AddEventAccess(ctx context.Context, db DBTX, arg AddEventAccessParams) (int64, error) {
	result, err := db.ExecContext(ctx, addEventAccess,
		arg.Event,
		arg.Expression,
		arg.Mode,
		arg.Validity,
		arg.Expires,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const attachFieldReportToIncident = `-- name: AttachFieldReportToIncident :exec
update FIELD_REPORT
set INCIDENT_NUMBER = ?
where EVENT = ? and NUMBER = ?
`

type AttachFieldReportToIncidentParams struct {
	IncidentNumber sql.NullInt32
	Event          int32
	Number         int32
}

func (q *Queries) AttachFieldReportToIncident(ctx context.Context, db DBTX, arg AttachFieldReportToIncidentParams) error {
	_, err := db.ExecContext(ctx, attachFieldReportToIncident, arg.IncidentNumber, arg.Event, arg.Number)
	return err
}

const attachIncidentTypeToIncident = `-- name: AttachIncidentTypeToIncident :exec
insert into INCIDENT__INCIDENT_TYPE (
    EVENT, INCIDENT_NUMBER, INCIDENT_TYPE
) values (
     ?, ?, ?
 )
`

type AttachIncidentTypeToIncidentParams struct {
	Event          int32
	IncidentNumber int32
	IncidentType   int32
}

func (q *Queries) AttachIncidentTypeToIncident(ctx context.Context, db DBTX, arg AttachIncidentTypeToIncidentParams) error {
	_, err := db.ExecContext(ctx, attachIncidentTypeToIncident, arg.Event, arg.IncidentNumber, arg.IncidentType)
	return err
}

const attachRangerHandleToIncident = `-- name: AttachRangerHandleToIncident :exec
insert into INCIDENT__RANGER (EVENT, INCIDENT_NUMBER, RANGER_HANDLE, ROLE)
values (?, ?, ?, ?)
`

type AttachRangerHandleToIncidentParams struct {
	Event          int32
	IncidentNumber int32
	RangerHandle   string
	Role           sql.NullString
}

func (q *Queries) AttachRangerHandleToIncident(ctx context.Context, db DBTX, arg AttachRangerHandleToIncidentParams) error {
	_, err := db.ExecContext(ctx, attachRangerHandleToIncident,
		arg.Event,
		arg.IncidentNumber,
		arg.RangerHandle,
		arg.Role,
	)
	return err
}

const attachRangerToStay = `-- name: AttachRangerToStay :exec
insert into STAY__RANGER (EVENT, STAY_NUMBER, RANGER_HANDLE, ROLE)
values (?, ?, ?, ?)
`

type AttachRangerToStayParams struct {
	Event        int32
	StayNumber   int32
	RangerHandle string
	Role         sql.NullString
}

func (q *Queries) AttachRangerToStay(ctx context.Context, db DBTX, arg AttachRangerToStayParams) error {
	_, err := db.ExecContext(ctx, attachRangerToStay,
		arg.Event,
		arg.StayNumber,
		arg.RangerHandle,
		arg.Role,
	)
	return err
}

const attachReportEntryToFieldReport = `-- name: AttachReportEntryToFieldReport :exec
insert into FIELD_REPORT__REPORT_ENTRY (
    EVENT, FIELD_REPORT_NUMBER, REPORT_ENTRY
) values (
    ?, ?, ?
)
`

type AttachReportEntryToFieldReportParams struct {
	Event             int32
	FieldReportNumber int32
	ReportEntry       int32
}

func (q *Queries) AttachReportEntryToFieldReport(ctx context.Context, db DBTX, arg AttachReportEntryToFieldReportParams) error {
	_, err := db.ExecContext(ctx, attachReportEntryToFieldReport, arg.Event, arg.FieldReportNumber, arg.ReportEntry)
	return err
}

const attachReportEntryToIncident = `-- name: AttachReportEntryToIncident :exec
insert into INCIDENT__REPORT_ENTRY (
    EVENT, INCIDENT_NUMBER, REPORT_ENTRY
) values (
    ?, ?, ?
)
`

type AttachReportEntryToIncidentParams struct {
	Event          int32
	IncidentNumber int32
	ReportEntry    int32
}

func (q *Queries) AttachReportEntryToIncident(ctx context.Context, db DBTX, arg AttachReportEntryToIncidentParams) error {
	_, err := db.ExecContext(ctx, attachReportEntryToIncident, arg.Event, arg.IncidentNumber, arg.ReportEntry)
	return err
}

const attachReportEntryToStay = `-- name: AttachReportEntryToStay :exec
insert into STAY__REPORT_ENTRY (
    EVENT, STAY_NUMBER, REPORT_ENTRY
) values (
    ?, ?, ?
)
`

type AttachReportEntryToStayParams struct {
	Event       int32
	StayNumber  int32
	ReportEntry int32
}

func (q *Queries) AttachReportEntryToStay(ctx context.Context, db DBTX, arg AttachReportEntryToStayParams) error {
	_, err := db.ExecContext(ctx, attachReportEntryToStay, arg.Event, arg.StayNumber, arg.ReportEntry)
	return err
}

const attachStayToIncident = `-- name: AttachStayToIncident :exec
update STAY
set INCIDENT_NUMBER = ?
where EVENT = ? and NUMBER = ?
`

type AttachStayToIncidentParams struct {
	IncidentNumber sql.NullInt32
	Event          int32
	Number         int32
}

func (q *Queries) AttachStayToIncident(ctx context.Context, db DBTX, arg AttachStayToIncidentParams) error {
	_, err := db.ExecContext(ctx, attachStayToIncident, arg.IncidentNumber, arg.Event, arg.Number)
	return err
}

const clearEventAccessForExpression = `-- name: ClearEventAccessForExpression :exec
delete from EVENT_ACCESS
where EVENT = ? and EXPRESSION = ?
`

type ClearEventAccessForExpressionParams struct {
	Event      int32
	Expression string
}

func (q *Queries) ClearEventAccessForExpression(ctx context.Context, db DBTX, arg ClearEventAccessForExpressionParams) error {
	_, err := db.ExecContext(ctx, clearEventAccessForExpression, arg.Event, arg.Expression)
	return err
}

const clearEventAccessForMode = `-- name: ClearEventAccessForMode :exec
delete from EVENT_ACCESS
where EVENT = ? and MODE = ?
`

type ClearEventAccessForModeParams struct {
	Event int32
	Mode  EventAccessMode
}

func (q *Queries) ClearEventAccessForMode(ctx context.Context, db DBTX, arg ClearEventAccessForModeParams) error {
	_, err := db.ExecContext(ctx, clearEventAccessForMode, arg.Event, arg.Mode)
	return err
}

const concentricStreets = `-- name: ConcentricStreets :many
select cs.event, cs.id, cs.name
from CONCENTRIC_STREET cs
where cs.EVENT = ?
`

type ConcentricStreetsRow struct {
	ConcentricStreet ConcentricStreet
}

func (q *Queries) ConcentricStreets(ctx context.Context, db DBTX, event int32) ([]ConcentricStreetsRow, error) {
	rows, err := db.QueryContext(ctx, concentricStreets, event)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ConcentricStreetsRow
	for rows.Next() {
		var i ConcentricStreetsRow
		if err := rows.Scan(&i.ConcentricStreet.Event, &i.ConcentricStreet.ID, &i.ConcentricStreet.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createConcentricStreet = `-- name: CreateConcentricStreet :exec
insert into CONCENTRIC_STREET (EVENT, ID, NAME)
values (?, ?, ?)
`

type CreateConcentricStreetParams struct {
	Event int32
	ID    string
	Name  string
}

func (q *Queries) CreateConcentricStreet(ctx context.Context, db DBTX, arg CreateConcentricStreetParams) error {
	_, err := db.ExecContext(ctx, createConcentricStreet, arg.Event, arg.ID, arg.Name)
	return err
}

const createDestination = `-- name: CreateDestination :exec
insert into DESTINATION
    (EVENT, NUMBER, TYPE, NAME, LOCATION_STRING, EXTERNAL_DATA)
values
    (?,?,?,?,?,?)
`

type CreateDestinationParams struct {
	Event          int32
	Number         int32
	Type           DestinationType
	Name           string
	LocationString string
	ExternalData   json.RawMessage
}

func (q *Queries) CreateDestination(ctx context.Context, db DBTX, arg CreateDestinationParams) error {
	_, err := db.ExecContext(ctx, createDestination,
		arg.Event,
		arg.Number,
		arg.Type,
		arg.Name,
		arg.LocationString,
		arg.ExternalData,
	)
	return err
}

const createEvent = `-- name: CreateEvent :execlastid
insert into EVENT (NAME, IS_GROUP, PARENT_GROUP) values (?, ?, ?)
`

type CreateEventParams struct {
	Name        string
	IsGroup     bool
	ParentGroup sql.NullInt32
}

func (q *Queries) CreateEvent(ctx context.Context, db DBTX, arg CreateEventParams) (int64, error) {
	result, err := db.ExecContext(ctx, createEvent, arg.Name, arg.IsGroup, arg.ParentGroup)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createFieldReport = `-- name: CreateFieldReport :exec
insert into FIELD_REPORT (
    EVENT, NUMBER, CREATED, SUMMARY, INCIDENT_NUMBER
)
values (?, ?, ?, ?, ?)
`

type CreateFieldReportParams struct {
	Event          int32
	Number         int32
	Created        float64
	Summary        sql.NullString
	IncidentNumber sql.NullInt32
}

func (q *Queries) CreateFieldReport(ctx context.Context, db DBTX, arg CreateFieldReportParams) error {
	_, err := db.ExecContext(ctx, createFieldReport,
		arg.Event,
		arg.Number,
		arg.Created,
		arg.Summary,
		arg.IncidentNumber,
	)
	return err
}

const createIncident = `-- name: CreateIncident :execlastid
insert into INCIDENT (
    EVENT,
    NUMBER,
    CREATED,
    PRIORITY,
    STATE,
    STARTED
)
values (
   ?,?,?,?,?,?
)
`

type CreateIncidentParams struct {
	Event    int32
	Number   int32
	Created  float64
	Priority int8
	State    IncidentState
	Started  float64
}

func (q *Queries) CreateIncident(ctx context.Context, db DBTX, arg CreateIncidentParams) (int64, error) {
	result, err := db.ExecContext(ctx, createIncident,
		arg.Event,
		arg.Number,
		arg.Created,
		arg.Priority,
		arg.State,
		arg.Started,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createIncidentType = `-- name: CreateIncidentType :execlastid
insert into INCIDENT_TYPE (NAME, HIDDEN)
values (?, ?)
`

type CreateIncidentTypeParams struct {
	Name   string
	Hidden bool
}

func (q *Queries) CreateIncidentType(ctx context.Context, db DBTX, arg CreateIncidentTypeParams) (int64, error) {
	result, err := db.ExecContext(ctx, createIncidentType, arg.Name, arg.Hidden)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createReportEntry = `-- name: CreateReportEntry :execlastid
insert into REPORT_ENTRY (
    AUTHOR, TEXT, CREATED, ` + "`" + `GENERATED` + "`" + `, STRICKEN,
    ATTACHED_FILE, ATTACHED_FILE_ORIGINAL_NAME, ATTACHED_FILE_MEDIA_TYPE
) values (
   ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateReportEntryParams struct {
	Author                   string
	Text                     string
	Created                  float64
	Generated                bool
	Stricken                 bool
	AttachedFile             sql.NullString
	AttachedFileOriginalName sql.NullString
	AttachedFileMediaType    sql.NullString
}

func (q *Queries) CreateReportEntry(ctx context.Context, db DBTX, arg CreateReportEntryParams) (int64, error) {
	result, err := db.ExecContext(ctx, createReportEntry,
		arg.Author,
		arg.Text,
		arg.Created,
		arg.Generated,
		arg.Stricken,
		arg.AttachedFile,
		arg.AttachedFileOriginalName,
		arg.AttachedFileMediaType,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createStay = `-- name: CreateStay :execlastid
insert into STAY (` + "`" + `EVENT` + "`" + `, NUMBER, CREATED) values (?, ?, ?)
`

type CreateStayParams struct {
	Event   int32
	Number  int32
	Created float64
}

func (q *Queries) CreateStay(ctx context.Context, db DBTX, arg CreateStayParams) (int64, error) {
	result, err := db.ExecContext(ctx, createStay, arg.Event, arg.Number, arg.Created)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const destinations = `-- name: Destinations :many
select
    EVENT,
    TYPE,
    NUMBER,
    NAME,
    LOCATION_STRING,
    if(?, '', EXTERNAL_DATA) as EXTERNAL_DATA
from
    DESTINATION d
where
    EVENT = ?
`

type DestinationsParams struct {
	ExcludeExternalData interface{}
	Event               int32
}

type DestinationsRow struct {
	Event          int32
	Type           DestinationType
	Number         int32
	Name           string
	LocationString string
	ExternalData   interface{}
}

func (q *Queries) Destinations(ctx context.Context, db DBTX, arg DestinationsParams) ([]DestinationsRow, error) {
	rows, err := db.QueryContext(ctx, destinations, arg.ExcludeExternalData, arg.Event)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DestinationsRow
	for rows.Next() {
		var i DestinationsRow
		if err := rows.Scan(
			&i.Event,
			&i.Type,
			&i.Number,
			&i.Name,
			&i.LocationString,
			&i.ExternalData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const detachIncidentTypeFromIncident = `-- name: DetachIncidentTypeFromIncident :exec
delete from INCIDENT__INCIDENT_TYPE
where
    EVENT = ?
    and INCIDENT_NUMBER = ?
    and INCIDENT_TYPE = ?
`

type DetachIncidentTypeFromIncidentParams struct {
	Event          int32
	IncidentNumber int32
	IncidentType   int32
}

func (q *Queries) DetachIncidentTypeFromIncident(ctx context.Context, db DBTX, arg DetachIncidentTypeFromIncidentParams) error {
	_, err := db.ExecContext(ctx, detachIncidentTypeFromIncident, arg.Event, arg.IncidentNumber, arg.IncidentType)
	return err
}

const detachRangerFromStay = `-- name: DetachRangerFromStay :exec
delete from STAY__RANGER
where
    EVENT = ?
    and STAY_NUMBER = ?
    and RANGER_HANDLE = ?
`

type DetachRangerFromStayParams struct {
	Event        int32
	StayNumber   int32
	RangerHandle string
}

func (q *Queries) DetachRangerFromStay(ctx context.Context, db DBTX, arg DetachRangerFromStayParams) error {
	_, err := db.ExecContext(ctx, detachRangerFromStay, arg.Event, arg.StayNumber, arg.RangerHandle)
	return err
}

const detachRangerHandleFromIncident = `-- name: DetachRangerHandleFromIncident :exec
delete from INCIDENT__RANGER
where
    EVENT = ?
    and INCIDENT_NUMBER = ?
    and RANGER_HANDLE = ?
`

type DetachRangerHandleFromIncidentParams struct {
	Event          int32
	IncidentNumber int32
	RangerHandle   string
}

func (q *Queries) DetachRangerHandleFromIncident(ctx context.Context, db DBTX, arg DetachRangerHandleFromIncidentParams) error {
	_, err := db.ExecContext(ctx, detachRangerHandleFromIncident, arg.Event, arg.IncidentNumber, arg.RangerHandle)
	return err
}

const event = `-- name: Event :one
select e.id, e.name, e.is_group, e.parent_group from EVENT e where ID = ?
`

type EventRow struct {
	Event Event
}

func (q *Queries) Event(ctx context.Context, db DBTX, id int32) (EventRow, error) {
	row := db.QueryRowContext(ctx, event, id)
	var i EventRow
	err := row.Scan(
		&i.Event.ID,
		&i.Event.Name,
		&i.Event.IsGroup,
		&i.Event.ParentGroup,
	)
	return i, err
}

const eventAccessAll = `-- name: EventAccessAll :many
select ea.id, ea.event, ea.expression, ea.mode, ea.validity, ea.expires
from EVENT_ACCESS ea
`

type EventAccessAllRow struct {
	EventAccess EventAccess
}

func (q *Queries) EventAccessAll(ctx context.Context, db DBTX) ([]EventAccessAllRow, error) {
	rows, err := db.QueryContext(ctx, eventAccessAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventAccessAllRow
	for rows.Next() {
		var i EventAccessAllRow
		if err := rows.Scan(
			&i.EventAccess.ID,
			&i.EventAccess.Event,
			&i.EventAccess.Expression,
			&i.EventAccess.Mode,
			&i.EventAccess.Validity,
			&i.EventAccess.Expires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const eventAndParentAccess = `-- name: EventAndParentAccess :many
select ea.id, ea.event, ea.expression, ea.mode, ea.validity, ea.expires
from ` + "`" + `EVENT` + "`" + ` e
    join EVENT_ACCESS ea
        on e.ID = ea.EVENT
where e.ID = ?
    and not e.IS_GROUP
union all
select ea.id, ea.event, ea.expression, ea.mode, ea.validity, ea.expires
from ` + "`" + `EVENT` + "`" + ` e
    join EVENT_ACCESS ea
        on e.PARENT_GROUP = ea.EVENT
where e.ID = ?
    and e.PARENT_GROUP is not null
`

type EventAndParentAccessParams struct {
	EventID int32
}

type EventAndParentAccessRow struct {
	EventAccess EventAccess
}

// This returns access for a target event, as well as for that event's
// parent group, if any. If the target event *is* a group, this query
// will return nothing. That's intentional, and it helps prevent people
// from adding incidents or FRs to event groups as though those were events.
func (q *Queries) EventAndParentAccess(ctx context.Context, db DBTX, arg EventAndParentAccessParams) ([]EventAndParentAccessRow, error) {
	rows, err := db.QueryContext(ctx, eventAndParentAccess, arg.EventID, arg.EventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventAndParentAccessRow
	for rows.Next() {
		var i EventAndParentAccessRow
		if err := rows.Scan(
			&i.EventAccess.ID,
			&i.EventAccess.Event,
			&i.EventAccess.Expression,
			&i.EventAccess.Mode,
			&i.EventAccess.Validity,
			&i.EventAccess.Expires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const events = `-- name: Events :many
select e.id, e.name, e.is_group, e.parent_group from EVENT e
`

type EventsRow struct {
	Event Event
}

func (q *Queries) Events(ctx context.Context, db DBTX) ([]EventsRow, error) {
	rows, err := db.QueryContext(ctx, events)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventsRow
	for rows.Next() {
		var i EventsRow
		if err := rows.Scan(
			&i.Event.ID,
			&i.Event.Name,
			&i.Event.IsGroup,
			&i.Event.ParentGroup,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fieldReport = `-- name: FieldReport :one
select fr.event, fr.number, fr.created, fr.summary, fr.incident_number
from FIELD_REPORT fr
where fr.EVENT = ?
    and fr.NUMBER = ?
`

type FieldReportParams struct {
	Event  int32
	Number int32
}

type FieldReportRow struct {
	FieldReport FieldReport
}

func (q *Queries) FieldReport(ctx context.Context, db DBTX, arg FieldReportParams) (FieldReportRow, error) {
	row := db.QueryRowContext(ctx, fieldReport, arg.Event, arg.Number)
	var i FieldReportRow
	err := row.Scan(
		&i.FieldReport.Event,
		&i.FieldReport.Number,
		&i.FieldReport.Created,
		&i.FieldReport.Summary,
		&i.FieldReport.IncidentNumber,
	)
	return i, err
}

const fieldReport_ReportEntries = `-- name: FieldReport_ReportEntries :many
select
    re.id, re.author, re.text, re.created, re.` + "`" + `generated` + "`" + `, re.stricken, re.attached_file, re.attached_file_original_name, re.attached_file_media_type
from
    FIELD_REPORT__REPORT_ENTRY irre
        join REPORT_ENTRY re
             on irre.REPORT_ENTRY = re.ID
where
    irre.EVENT = ?
    and irre.FIELD_REPORT_NUMBER = ?
`

type FieldReport_ReportEntriesParams struct {
	Event             int32
	FieldReportNumber int32
}

type FieldReport_ReportEntriesRow struct {
	ReportEntry ReportEntry
}

func (q *Queries) FieldReport_ReportEntries(ctx context.Context, db DBTX, arg FieldReport_ReportEntriesParams) ([]FieldReport_ReportEntriesRow, error) {
	rows, err := db.QueryContext(ctx, fieldReport_ReportEntries, arg.Event, arg.FieldReportNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FieldReport_ReportEntriesRow
	for rows.Next() {
		var i FieldReport_ReportEntriesRow
		if err := rows.Scan(
			&i.ReportEntry.ID,
			&i.ReportEntry.Author,
			&i.ReportEntry.Text,
			&i.ReportEntry.Created,
			&i.ReportEntry.Generated,
			&i.ReportEntry.Stricken,
			&i.ReportEntry.AttachedFile,
			&i.ReportEntry.AttachedFileOriginalName,
			&i.ReportEntry.AttachedFileMediaType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fieldReports = `-- name: FieldReports :many
select fr.event, fr.number, fr.created, fr.summary, fr.incident_number
from FIELD_REPORT fr
where fr.EVENT = ?
`

type FieldReportsRow struct {
	FieldReport FieldReport
}

func (q *Queries) FieldReports(ctx context.Context, db DBTX, event int32) ([]FieldReportsRow, error) {
	rows, err := db.QueryContext(ctx, fieldReports, event)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FieldReportsRow
	for rows.Next() {
		var i FieldReportsRow
		if err := rows.Scan(
			&i.FieldReport.Event,
			&i.FieldReport.Number,
			&i.FieldReport.Created,
			&i.FieldReport.Summary,
			&i.FieldReport.IncidentNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fieldReports_ReportEntries = `-- name: FieldReports_ReportEntries :many
select
    irre.FIELD_REPORT_NUMBER,
    re.id, re.author, re.text, re.created, re.` + "`" + `generated` + "`" + `, re.stricken, re.attached_file, re.attached_file_original_name, re.attached_file_media_type
from
    FIELD_REPORT__REPORT_ENTRY irre
        join REPORT_ENTRY re
             on irre.REPORT_ENTRY = re.ID
where
    irre.EVENT = ?
    and re.GENERATED <= ?
`

type FieldReports_ReportEntriesParams struct {
	Event     int32
	Generated bool
}

type FieldReports_ReportEntriesRow struct {
	FieldReportNumber int32
	ReportEntry       ReportEntry
}

func (q *Queries) FieldReports_ReportEntries(ctx context.Context, db DBTX, arg FieldReports_ReportEntriesParams) ([]FieldReports_ReportEntriesRow, error) {
	rows, err := db.QueryContext(ctx, fieldReports_ReportEntries, arg.Event, arg.Generated)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FieldReports_ReportEntriesRow
	for rows.Next() {
		var i FieldReports_ReportEntriesRow
		if err := rows.Scan(
			&i.FieldReportNumber,
			&i.ReportEntry.ID,
			&i.ReportEntry.Author,
			&i.ReportEntry.Text,
			&i.ReportEntry.Created,
			&i.ReportEntry.Generated,
			&i.ReportEntry.Stricken,
			&i.ReportEntry.AttachedFile,
			&i.ReportEntry.AttachedFileOriginalName,
			&i.ReportEntry.AttachedFileMediaType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incident = `-- name: Incident :one
select
    i.event, i.number, i.created, i.priority, i.state, i.started, i.closed, i.summary, i.location_name, i.location_address, i.location_concentric, i.location_radial_hour, i.location_radial_minute, i.location_description,
    (
        select coalesce(json_arrayagg(iit.INCIDENT_TYPE), "[]")
        from INCIDENT__INCIDENT_TYPE iit
        where i.EVENT = iit.EVENT
          and i.NUMBER = iit.INCIDENT_NUMBER
    ) as INCIDENT_TYPE_IDS,
    (
        select coalesce(json_arrayagg(irep.NUMBER), "[]")
        from FIELD_REPORT irep
        where i.EVENT = irep.EVENT
          and i.NUMBER = irep.INCIDENT_NUMBER
    ) as FIELD_REPORT_NUMBERS,
    (
        select coalesce(json_arrayagg(stay.NUMBER), "[]")
        from STAY stay
        where i.EVENT = stay.EVENT
          and i.NUMBER = stay.INCIDENT_NUMBER
    ) as STAY_NUMBERS
from INCIDENT i
where i.EVENT = ?
    and i.NUMBER = ?
`

type IncidentParams struct {
	Event  int32
	Number int32
}

type IncidentRow struct {
	Incident           Incident
	IncidentTypeIds    interface{}
	FieldReportNumbers interface{}
	StayNumbers        interface{}
}

func (q *Queries) Incident(ctx context.Context, db DBTX, arg IncidentParams) (IncidentRow, error) {
	row := db.QueryRowContext(ctx, incident, arg.Event, arg.Number)
	var i IncidentRow
	err := row.Scan(
		&i.Incident.Event,
		&i.Incident.Number,
		&i.Incident.Created,
		&i.Incident.Priority,
		&i.Incident.State,
		&i.Incident.Started,
		&i.Incident.Closed,
		&i.Incident.Summary,
		&i.Incident.LocationName,
		&i.Incident.LocationAddress,
		&i.Incident.LocationConcentric,
		&i.Incident.LocationRadialHour,
		&i.Incident.LocationRadialMinute,
		&i.Incident.LocationDescription,
		&i.IncidentTypeIds,
		&i.FieldReportNumbers,
		&i.StayNumbers,
	)
	return i, err
}

const incidentType = `-- name: IncidentType :one
select it.id, it.name, it.hidden, it.description
from INCIDENT_TYPE it
where it.ID = ?
`

type IncidentTypeRow struct {
	IncidentType IncidentType
}

func (q *Queries) IncidentType(ctx context.Context, db DBTX, id int32) (IncidentTypeRow, error) {
	row := db.QueryRowContext(ctx, incidentType, id)
	var i IncidentTypeRow
	err := row.Scan(
		&i.IncidentType.ID,
		&i.IncidentType.Name,
		&i.IncidentType.Hidden,
		&i.IncidentType.Description,
	)
	return i, err
}

const incidentTypes = `-- name: IncidentTypes :many
select it.id, it.name, it.hidden, it.description
from INCIDENT_TYPE it
`

type IncidentTypesRow struct {
	IncidentType IncidentType
}

func (q *Queries) IncidentTypes(ctx context.Context, db DBTX) ([]IncidentTypesRow, error) {
	rows, err := db.QueryContext(ctx, incidentTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IncidentTypesRow
	for rows.Next() {
		var i IncidentTypesRow
		if err := rows.Scan(
			&i.IncidentType.ID,
			&i.IncidentType.Name,
			&i.IncidentType.Hidden,
			&i.IncidentType.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incident_LinkedIncidents = `-- name: Incident_LinkedIncidents :many
select
    ili.EVENT_2 as LINKED_EVENT,
    e.NAME as LINKED_EVENT_NAME,
    ili.INCIDENT_NUMBER_2 as LINKED_INCIDENT,
    i2.SUMMARY as LINKED_INCIDENT_SUMMARY
from
    INCIDENT__LINKED_INCIDENT ili
    join ` + "`" + `EVENT` + "`" + ` e
        on e.ID = ili.EVENT_2
    join INCIDENT i2
        on i2.EVENT = ili.EVENT_2
            and i2.NUMBER = ili.INCIDENT_NUMBER_2
where
    ili.EVENT_1 = ?
    and ili.INCIDENT_NUMBER_1 = ?
`

type Incident_LinkedIncidentsParams struct {
	Event1          int32
	IncidentNumber1 int32
}

type Incident_LinkedIncidentsRow struct {
	LinkedEvent           int32
	LinkedEventName       string
	LinkedIncident        int32
	LinkedIncidentSummary sql.NullString
}

func (q *Queries) Incident_LinkedIncidents(ctx context.Context, db DBTX, arg Incident_LinkedIncidentsParams) ([]Incident_LinkedIncidentsRow, error) {
	rows, err := db.QueryContext(ctx, incident_LinkedIncidents, arg.Event1, arg.IncidentNumber1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Incident_LinkedIncidentsRow
	for rows.Next() {
		var i Incident_LinkedIncidentsRow
		if err := rows.Scan(
			&i.LinkedEvent,
			&i.LinkedEventName,
			&i.LinkedIncident,
			&i.LinkedIncidentSummary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incident_Rangers = `-- name: Incident_Rangers :many
select
    ir.id, ir.event, ir.incident_number, ir.ranger_handle, ir.role
from
    INCIDENT__RANGER ir
where
    ir.EVENT = ?
    and ir.INCIDENT_NUMBER = ?
`

type Incident_RangersParams struct {
	Event          int32
	IncidentNumber int32
}

type Incident_RangersRow struct {
	IncidentRanger IncidentRanger
}

func (q *Queries) Incident_Rangers(ctx context.Context, db DBTX, arg Incident_RangersParams) ([]Incident_RangersRow, error) {
	rows, err := db.QueryContext(ctx, incident_Rangers, arg.Event, arg.IncidentNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Incident_RangersRow
	for rows.Next() {
		var i Incident_RangersRow
		if err := rows.Scan(
			&i.IncidentRanger.ID,
			&i.IncidentRanger.Event,
			&i.IncidentRanger.IncidentNumber,
			&i.IncidentRanger.RangerHandle,
			&i.IncidentRanger.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incident_ReportEntries = `-- name: Incident_ReportEntries :many
select
    ire.INCIDENT_NUMBER,
    re.id, re.author, re.text, re.created, re.` + "`" + `generated` + "`" + `, re.stricken, re.attached_file, re.attached_file_original_name, re.attached_file_media_type
from
    INCIDENT__REPORT_ENTRY ire
        join REPORT_ENTRY re
             on re.ID = ire.REPORT_ENTRY
where
    ire.EVENT = ?
    and ire.INCIDENT_NUMBER = ?
`

type Incident_ReportEntriesParams struct {
	Event          int32
	IncidentNumber int32
}

type Incident_ReportEntriesRow struct {
	IncidentNumber int32
	ReportEntry    ReportEntry
}

func (q *Queries) Incident_ReportEntries(ctx context.Context, db DBTX, arg Incident_ReportEntriesParams) ([]Incident_ReportEntriesRow, error) {
	rows, err := db.QueryContext(ctx, incident_ReportEntries, arg.Event, arg.IncidentNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Incident_ReportEntriesRow
	for rows.Next() {
		var i Incident_ReportEntriesRow
		if err := rows.Scan(
			&i.IncidentNumber,
			&i.ReportEntry.ID,
			&i.ReportEntry.Author,
			&i.ReportEntry.Text,
			&i.ReportEntry.Created,
			&i.ReportEntry.Generated,
			&i.ReportEntry.Stricken,
			&i.ReportEntry.AttachedFile,
			&i.ReportEntry.AttachedFileOriginalName,
			&i.ReportEntry.AttachedFileMediaType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incidents = `-- name: Incidents :many
select
    i.event, i.number, i.created, i.priority, i.state, i.started, i.closed, i.summary, i.location_name, i.location_address, i.location_concentric, i.location_radial_hour, i.location_radial_minute, i.location_description,
    (
        select coalesce(json_arrayagg(iit.INCIDENT_TYPE), "[]")
        from INCIDENT__INCIDENT_TYPE iit
        where i.EVENT = iit.EVENT
            and i.NUMBER = iit.INCIDENT_NUMBER
    ) as INCIDENT_TYPE_IDS,
    (
        select coalesce(json_arrayagg(irep.NUMBER), "[]")
        from FIELD_REPORT irep
        where i.EVENT = irep.EVENT
            and i.NUMBER = irep.INCIDENT_NUMBER
    ) as FIELD_REPORT_NUMBERS,
    (
        select coalesce(json_arrayagg(stay.NUMBER), "[]")
        from STAY stay
        where i.EVENT = stay.EVENT
          and i.NUMBER = stay.INCIDENT_NUMBER
    ) as STAY_NUMBERS
from
    INCIDENT i
where
    i.EVENT = ?
group by
    i.NUMBER
`

type IncidentsRow struct {
	Incident           Incident
	IncidentTypeIds    interface{}
	FieldReportNumbers interface{}
	StayNumbers        interface{}
}

func (q *Queries) Incidents(ctx context.Context, db DBTX, event int32) ([]IncidentsRow, error) {
	rows, err := db.QueryContext(ctx, incidents, event)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IncidentsRow
	for rows.Next() {
		var i IncidentsRow
		if err := rows.Scan(
			&i.Incident.Event,
			&i.Incident.Number,
			&i.Incident.Created,
			&i.Incident.Priority,
			&i.Incident.State,
			&i.Incident.Started,
			&i.Incident.Closed,
			&i.Incident.Summary,
			&i.Incident.LocationName,
			&i.Incident.LocationAddress,
			&i.Incident.LocationConcentric,
			&i.Incident.LocationRadialHour,
			&i.Incident.LocationRadialMinute,
			&i.Incident.LocationDescription,
			&i.IncidentTypeIds,
			&i.FieldReportNumbers,
			&i.StayNumbers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incidents_Rangers = `-- name: Incidents_Rangers :many
select
    ir.id, ir.event, ir.incident_number, ir.ranger_handle, ir.role
from
    INCIDENT__RANGER ir
where
    ir.EVENT = ?
`

type Incidents_RangersRow struct {
	IncidentRanger IncidentRanger
}

func (q *Queries) Incidents_Rangers(ctx context.Context, db DBTX, event int32) ([]Incidents_RangersRow, error) {
	rows, err := db.QueryContext(ctx, incidents_Rangers, event)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Incidents_RangersRow
	for rows.Next() {
		var i Incidents_RangersRow
		if err := rows.Scan(
			&i.IncidentRanger.ID,
			&i.IncidentRanger.Event,
			&i.IncidentRanger.IncidentNumber,
			&i.IncidentRanger.RangerHandle,
			&i.IncidentRanger.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incidents_ReportEntries = `-- name: Incidents_ReportEntries :many
select
    ire.INCIDENT_NUMBER,
    re.id, re.author, re.text, re.created, re.` + "`" + `generated` + "`" + `, re.stricken, re.attached_file, re.attached_file_original_name, re.attached_file_media_type
from
    INCIDENT__REPORT_ENTRY ire
        join REPORT_ENTRY re
             on re.ID = ire.REPORT_ENTRY
where
    ire.EVENT = ?
    and re.GENERATED <= ?
`

type Incidents_ReportEntriesParams struct {
	Event     int32
	Generated bool
}

type Incidents_ReportEntriesRow struct {
	IncidentNumber int32
	ReportEntry    ReportEntry
}

func (q *Queries) Incidents_ReportEntries(ctx context.Context, db DBTX, arg Incidents_ReportEntriesParams) ([]Incidents_ReportEntriesRow, error) {
	rows, err := db.QueryContext(ctx, incidents_ReportEntries, arg.Event, arg.Generated)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Incidents_ReportEntriesRow
	for rows.Next() {
		var i Incidents_ReportEntriesRow
		if err := rows.Scan(
			&i.IncidentNumber,
			&i.ReportEntry.ID,
			&i.ReportEntry.Author,
			&i.ReportEntry.Text,
			&i.ReportEntry.Created,
			&i.ReportEntry.Generated,
			&i.ReportEntry.Stricken,
			&i.ReportEntry.AttachedFile,
			&i.ReportEntry.AttachedFileOriginalName,
			&i.ReportEntry.AttachedFileMediaType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkIncidents = `-- name: LinkIncidents :exec
insert into INCIDENT__LINKED_INCIDENT
    (EVENT_1, INCIDENT_NUMBER_1, EVENT_2, INCIDENT_NUMBER_2)
values
    (?, ?, ?, ?)
`

type LinkIncidentsParams struct {
	Event1          int32
	IncidentNumber1 int32
	Event2          int32
	IncidentNumber2 int32
}

func (q *Queries) LinkIncidents(ctx context.Context, db DBTX, arg LinkIncidentsParams) error {
	_, err := db.ExecContext(ctx, linkIncidents,
		arg.Event1,
		arg.IncidentNumber1,
		arg.Event2,
		arg.IncidentNumber2,
	)
	return err
}

const nextFieldReportNumber = `-- name: NextFieldReportNumber :one
select NUMBER + 1 as NEXT_ID
from FIELD_REPORT
where EVENT = ?
union
select 1
order by 1 desc
limit 1
`

// This doesn't use "MAX" because sqlc can't figure out the type for aggregations :(.
func (q *Queries) NextFieldReportNumber(ctx context.Context, db DBTX, event int32) (int32, error) {
	row := db.QueryRowContext(ctx, nextFieldReportNumber, event)
	var next_id int32
	err := row.Scan(&next_id)
	return next_id, err
}

const nextIncidentNumber = `-- name: NextIncidentNumber :one
select NUMBER + 1 as NEXT_ID
from INCIDENT
where EVENT = ?
union
select 1
order by 1 desc
limit 1
`

// This doesn't use "MAX" because sqlc can't figure out the type for aggregations :(.
func (q *Queries) NextIncidentNumber(ctx context.Context, db DBTX, event int32) (int32, error) {
	row := db.QueryRowContext(ctx, nextIncidentNumber, event)
	var next_id int32
	err := row.Scan(&next_id)
	return next_id, err
}

const nextStayNumber = `-- name: NextStayNumber :one
select NUMBER + 1 as NEXT_ID
from STAY
where EVENT = ?
union
select 1
order by 1 desc
limit 1
`

// This doesn't use "MAX" because sqlc can't figure out the type for aggregations :(.
func (q *Queries) NextStayNumber(ctx context.Context, db DBTX, event int32) (int32, error) {
	row := db.QueryRowContext(ctx, nextStayNumber, event)
	var next_id int32
	err := row.Scan(&next_id)
	return next_id, err
}

const queryEventID = `-- name: QueryEventID :one
select e.id, e.name, e.is_group, e.parent_group from EVENT e where e.NAME = ?
`

type QueryEventIDRow struct {
	Event Event
}

func (q *Queries) QueryEventID(ctx context.Context, db DBTX, name string) (QueryEventIDRow, error) {
	row := db.QueryRowContext(ctx, queryEventID, name)
	var i QueryEventIDRow
	err := row.Scan(
		&i.Event.ID,
		&i.Event.Name,
		&i.Event.IsGroup,
		&i.Event.ParentGroup,
	)
	return i, err
}

const removeDestinations = `-- name: RemoveDestinations :exec
delete from
    DESTINATION
where EVENT = ?
    and TYPE = ?
`

type RemoveDestinationsParams struct {
	Event int32
	Type  DestinationType
}

func (q *Queries) RemoveDestinations(ctx context.Context, db DBTX, arg RemoveDestinationsParams) error {
	_, err := db.ExecContext(ctx, removeDestinations, arg.Event, arg.Type)
	return err
}

const schemaVersion = `-- name: SchemaVersion :one
select VERSION from SCHEMA_INFO
`

func (q *Queries) SchemaVersion(ctx context.Context, db DBTX) (int16, error) {
	row := db.QueryRowContext(ctx, schemaVersion)
	var version int16
	err := row.Scan(&version)
	return version, err
}

const setFieldReportReportEntryStricken = `-- name: SetFieldReportReportEntryStricken :exec
update REPORT_ENTRY
set STRICKEN = ?
where ID IN (
    select REPORT_ENTRY
    from FIELD_REPORT__REPORT_ENTRY
    where EVENT = ?
      and FIELD_REPORT_NUMBER = ?
      and REPORT_ENTRY = ?
)
`

type SetFieldReportReportEntryStrickenParams struct {
	Stricken          bool
	Event             int32
	FieldReportNumber int32
	ReportEntry       int32
}

func (q *Queries) SetFieldReportReportEntryStricken(ctx context.Context, db DBTX, arg SetFieldReportReportEntryStrickenParams) error {
	_, err := db.ExecContext(ctx, setFieldReportReportEntryStricken,
		arg.Stricken,
		arg.Event,
		arg.FieldReportNumber,
		arg.ReportEntry,
	)
	return err
}

const setIncidentReportEntryStricken = `-- name: SetIncidentReportEntryStricken :exec

update REPORT_ENTRY
set STRICKEN = ?
where ID IN (
    select REPORT_ENTRY
    from INCIDENT__REPORT_ENTRY
    where EVENT = ?
        and INCIDENT_NUMBER = ?
        and REPORT_ENTRY = ?
)
`

type SetIncidentReportEntryStrickenParams struct {
	Stricken       bool
	Event          int32
	IncidentNumber int32
	ReportEntry    int32
}

// The "stricken" queries seem bloated at first blush, because the whole
// "where ID in (..." could just be "where ID =". What it's doing though is
// ensuring that the provided eventID and incidentNumber actually align with
// the reportEntryID in question, and that's important for authorization purposes.
func (q *Queries) SetIncidentReportEntryStricken(ctx context.Context, db DBTX, arg SetIncidentReportEntryStrickenParams) error {
	_, err := db.ExecContext(ctx, setIncidentReportEntryStricken,
		arg.Stricken,
		arg.Event,
		arg.IncidentNumber,
		arg.ReportEntry,
	)
	return err
}

const setStayReportEntryStricken = `-- name: SetStayReportEntryStricken :exec
update REPORT_ENTRY
set STRICKEN = ?
where ID IN (
    select REPORT_ENTRY
    from STAY__REPORT_ENTRY
    where EVENT = ?
      and STAY_NUMBER = ?
      and REPORT_ENTRY = ?
)
`

type SetStayReportEntryStrickenParams struct {
	Stricken    bool
	Event       int32
	StayNumber  int32
	ReportEntry int32
}

func (q *Queries) SetStayReportEntryStricken(ctx context.Context, db DBTX, arg SetStayReportEntryStrickenParams) error {
	_, err := db.ExecContext(ctx, setStayReportEntryStricken,
		arg.Stricken,
		arg.Event,
		arg.StayNumber,
		arg.ReportEntry,
	)
	return err
}

const stay = `-- name: Stay :one
select
    s.event, s.number, s.created, s.incident_number, s.guest_preferred_name, s.guest_legal_name, s.guest_description, s.guest_camp_name, s.guest_camp_address, s.guest_camp_description, s.arrival_time, s.arrival_method, s.arrival_state, s.arrival_reason, s.arrival_belongings, s.departure_time, s.departure_method, s.departure_state, s.resource_rest, s.resource_clothes, s.resource_pogs, s.resource_food_bev, s.resource_other
from
    STAY s
where
    s.EVENT = ?
    and s.NUMBER = ?
`

type StayParams struct {
	Event  int32
	Number int32
}

type StayRow struct {
	Stay Stay
}

func (q *Queries) Stay(ctx context.Context, db DBTX, arg StayParams) (StayRow, error) {
	row := db.QueryRowContext(ctx, stay, arg.Event, arg.Number)
	var i StayRow
	err := row.Scan(
		&i.Stay.Event,
		&i.Stay.Number,
		&i.Stay.Created,
		&i.Stay.IncidentNumber,
		&i.Stay.GuestPreferredName,
		&i.Stay.GuestLegalName,
		&i.Stay.GuestDescription,
		&i.Stay.GuestCampName,
		&i.Stay.GuestCampAddress,
		&i.Stay.GuestCampDescription,
		&i.Stay.ArrivalTime,
		&i.Stay.ArrivalMethod,
		&i.Stay.ArrivalState,
		&i.Stay.ArrivalReason,
		&i.Stay.ArrivalBelongings,
		&i.Stay.DepartureTime,
		&i.Stay.DepartureMethod,
		&i.Stay.DepartureState,
		&i.Stay.ResourceRest,
		&i.Stay.ResourceClothes,
		&i.Stay.ResourcePogs,
		&i.Stay.ResourceFoodBev,
		&i.Stay.ResourceOther,
	)
	return i, err
}

const stay_Rangers = `-- name: Stay_Rangers :many
select
    sr.id, sr.event, sr.stay_number, sr.ranger_handle, sr.role
from
    STAY__RANGER sr
where
    sr.EVENT = ?
    and sr.STAY_NUMBER = ?
`

type Stay_RangersParams struct {
	Event      int32
	StayNumber int32
}

type Stay_RangersRow struct {
	StayRanger StayRanger
}

func (q *Queries) Stay_Rangers(ctx context.Context, db DBTX, arg Stay_RangersParams) ([]Stay_RangersRow, error) {
	rows, err := db.QueryContext(ctx, stay_Rangers, arg.Event, arg.StayNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stay_RangersRow
	for rows.Next() {
		var i Stay_RangersRow
		if err := rows.Scan(
			&i.StayRanger.ID,
			&i.StayRanger.Event,
			&i.StayRanger.StayNumber,
			&i.StayRanger.RangerHandle,
			&i.StayRanger.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const stay_ReportEntries = `-- name: Stay_ReportEntries :many
select
    sre.STAY_NUMBER,
    re.id, re.author, re.text, re.created, re.` + "`" + `generated` + "`" + `, re.stricken, re.attached_file, re.attached_file_original_name, re.attached_file_media_type
from
    STAY__REPORT_ENTRY sre
        join REPORT_ENTRY re
             on re.ID = sre.REPORT_ENTRY
where
    sre.EVENT = ?
    and sre.STAY_NUMBER = ?
`

type Stay_ReportEntriesParams struct {
	Event      int32
	StayNumber int32
}

type Stay_ReportEntriesRow struct {
	StayNumber  int32
	ReportEntry ReportEntry
}

func (q *Queries) Stay_ReportEntries(ctx context.Context, db DBTX, arg Stay_ReportEntriesParams) ([]Stay_ReportEntriesRow, error) {
	rows, err := db.QueryContext(ctx, stay_ReportEntries, arg.Event, arg.StayNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stay_ReportEntriesRow
	for rows.Next() {
		var i Stay_ReportEntriesRow
		if err := rows.Scan(
			&i.StayNumber,
			&i.ReportEntry.ID,
			&i.ReportEntry.Author,
			&i.ReportEntry.Text,
			&i.ReportEntry.Created,
			&i.ReportEntry.Generated,
			&i.ReportEntry.Stricken,
			&i.ReportEntry.AttachedFile,
			&i.ReportEntry.AttachedFileOriginalName,
			&i.ReportEntry.AttachedFileMediaType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const stays = `-- name: Stays :many
select
    s.event, s.number, s.created, s.incident_number, s.guest_preferred_name, s.guest_legal_name, s.guest_description, s.guest_camp_name, s.guest_camp_address, s.guest_camp_description, s.arrival_time, s.arrival_method, s.arrival_state, s.arrival_reason, s.arrival_belongings, s.departure_time, s.departure_method, s.departure_state, s.resource_rest, s.resource_clothes, s.resource_pogs, s.resource_food_bev, s.resource_other
from
    STAY s
where
    s.EVENT = ?
group by
    s.NUMBER
`

type StaysRow struct {
	Stay Stay
}

func (q *Queries) Stays(ctx context.Context, db DBTX, event int32) ([]StaysRow, error) {
	rows, err := db.QueryContext(ctx, stays, event)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StaysRow
	for rows.Next() {
		var i StaysRow
		if err := rows.Scan(
			&i.Stay.Event,
			&i.Stay.Number,
			&i.Stay.Created,
			&i.Stay.IncidentNumber,
			&i.Stay.GuestPreferredName,
			&i.Stay.GuestLegalName,
			&i.Stay.GuestDescription,
			&i.Stay.GuestCampName,
			&i.Stay.GuestCampAddress,
			&i.Stay.GuestCampDescription,
			&i.Stay.ArrivalTime,
			&i.Stay.ArrivalMethod,
			&i.Stay.ArrivalState,
			&i.Stay.ArrivalReason,
			&i.Stay.ArrivalBelongings,
			&i.Stay.DepartureTime,
			&i.Stay.DepartureMethod,
			&i.Stay.DepartureState,
			&i.Stay.ResourceRest,
			&i.Stay.ResourceClothes,
			&i.Stay.ResourcePogs,
			&i.Stay.ResourceFoodBev,
			&i.Stay.ResourceOther,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const stays_Rangers = `-- name: Stays_Rangers :many
select
    sr.id, sr.event, sr.stay_number, sr.ranger_handle, sr.role
from
    STAY__RANGER sr
where
    sr.EVENT = ?
`

type Stays_RangersRow struct {
	StayRanger StayRanger
}

func (q *Queries) Stays_Rangers(ctx context.Context, db DBTX, event int32) ([]Stays_RangersRow, error) {
	rows, err := db.QueryContext(ctx, stays_Rangers, event)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stays_RangersRow
	for rows.Next() {
		var i Stays_RangersRow
		if err := rows.Scan(
			&i.StayRanger.ID,
			&i.StayRanger.Event,
			&i.StayRanger.StayNumber,
			&i.StayRanger.RangerHandle,
			&i.StayRanger.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const stays_ReportEntries = `-- name: Stays_ReportEntries :many
select
    sre.STAY_NUMBER,
    re.id, re.author, re.text, re.created, re.` + "`" + `generated` + "`" + `, re.stricken, re.attached_file, re.attached_file_original_name, re.attached_file_media_type
from
    STAY__REPORT_ENTRY sre
        join REPORT_ENTRY re
             on re.ID = sre.REPORT_ENTRY
where
    sre.EVENT = ?
    and re.GENERATED <= ?
`

type Stays_ReportEntriesParams struct {
	Event     int32
	Generated bool
}

type Stays_ReportEntriesRow struct {
	StayNumber  int32
	ReportEntry ReportEntry
}

func (q *Queries) Stays_ReportEntries(ctx context.Context, db DBTX, arg Stays_ReportEntriesParams) ([]Stays_ReportEntriesRow, error) {
	rows, err := db.QueryContext(ctx, stays_ReportEntries, arg.Event, arg.Generated)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Stays_ReportEntriesRow
	for rows.Next() {
		var i Stays_ReportEntriesRow
		if err := rows.Scan(
			&i.StayNumber,
			&i.ReportEntry.ID,
			&i.ReportEntry.Author,
			&i.ReportEntry.Text,
			&i.ReportEntry.Created,
			&i.ReportEntry.Generated,
			&i.ReportEntry.Stricken,
			&i.ReportEntry.AttachedFile,
			&i.ReportEntry.AttachedFileOriginalName,
			&i.ReportEntry.AttachedFileMediaType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unlinkIncidents = `-- name: UnlinkIncidents :exec
delete from INCIDENT__LINKED_INCIDENT
where
    EVENT_1 = ?
    and INCIDENT_NUMBER_1 = ?
    and EVENT_2 = ?
    and INCIDENT_NUMBER_2 = ?
`

type UnlinkIncidentsParams struct {
	Event1          int32
	IncidentNumber1 int32
	Event2          int32
	IncidentNumber2 int32
}

func (q *Queries) UnlinkIncidents(ctx context.Context, db DBTX, arg UnlinkIncidentsParams) error {
	_, err := db.ExecContext(ctx, unlinkIncidents,
		arg.Event1,
		arg.IncidentNumber1,
		arg.Event2,
		arg.IncidentNumber2,
	)
	return err
}

const updateEvent = `-- name: UpdateEvent :exec
update ` + "`" + `EVENT` + "`" + `
set
    NAME = ?,
    IS_GROUP = ?,
    PARENT_GROUP = ?
where ID = ?
`

type UpdateEventParams struct {
	Name        string
	IsGroup     bool
	ParentGroup sql.NullInt32
	ID          int32
}

func (q *Queries) UpdateEvent(ctx context.Context, db DBTX, arg UpdateEventParams) error {
	_, err := db.ExecContext(ctx, updateEvent,
		arg.Name,
		arg.IsGroup,
		arg.ParentGroup,
		arg.ID,
	)
	return err
}

const updateFieldReport = `-- name: UpdateFieldReport :exec
update FIELD_REPORT
set SUMMARY = ?, INCIDENT_NUMBER = ?
where EVENT = ? and NUMBER = ?
`

type UpdateFieldReportParams struct {
	Summary        sql.NullString
	IncidentNumber sql.NullInt32
	Event          int32
	Number         int32
}

func (q *Queries) UpdateFieldReport(ctx context.Context, db DBTX, arg UpdateFieldReportParams) error {
	_, err := db.ExecContext(ctx, updateFieldReport,
		arg.Summary,
		arg.IncidentNumber,
		arg.Event,
		arg.Number,
	)
	return err
}

const updateIncident = `-- name: UpdateIncident :exec
update INCIDENT set
    -- CREATED should be immutable, so it's not present in this UPDATE query
    PRIORITY = ?,
    STATE = ?,
    STARTED = ?,
    CLOSED = ?,
    SUMMARY = ?,
    LOCATION_NAME = ?,
    LOCATION_ADDRESS = ?,
    LOCATION_CONCENTRIC = ?,
    LOCATION_RADIAL_HOUR = ?,
    LOCATION_RADIAL_MINUTE = ?,
    LOCATION_DESCRIPTION = ?
where
    EVENT = ?
    and NUMBER = ?
`

type UpdateIncidentParams struct {
	Priority             int8
	State                IncidentState
	Started              float64
	Closed               sql.NullFloat64
	Summary              sql.NullString
	LocationName         sql.NullString
	LocationAddress      sql.NullString
	LocationConcentric   sql.NullString
	LocationRadialHour   sql.NullInt16
	LocationRadialMinute sql.NullInt16
	LocationDescription  sql.NullString
	Event                int32
	Number               int32
}

func (q *Queries) UpdateIncident(ctx context.Context, db DBTX, arg UpdateIncidentParams) error {
	_, err := db.ExecContext(ctx, updateIncident,
		arg.Priority,
		arg.State,
		arg.Started,
		arg.Closed,
		arg.Summary,
		arg.LocationName,
		arg.LocationAddress,
		arg.LocationConcentric,
		arg.LocationRadialHour,
		arg.LocationRadialMinute,
		arg.LocationDescription,
		arg.Event,
		arg.Number,
	)
	return err
}

const updateIncidentType = `-- name: UpdateIncidentType :exec
update INCIDENT_TYPE
set HIDDEN = ?,
    NAME = ?,
    DESCRIPTION = ?
where ID = ?
`

type UpdateIncidentTypeParams struct {
	Hidden      bool
	Name        string
	Description sql.NullString
	ID          int32
}

func (q *Queries) UpdateIncidentType(ctx context.Context, db DBTX, arg UpdateIncidentTypeParams) error {
	_, err := db.ExecContext(ctx, updateIncidentType,
		arg.Hidden,
		arg.Name,
		arg.Description,
		arg.ID,
	)
	return err
}

const updateStay = `-- name: UpdateStay :exec
update STAY set
    -- CREATED should be immutable, so it's not present in this UPDATE query
    INCIDENT_NUMBER = ?,
    GUEST_PREFERRED_NAME = ?,
    GUEST_LEGAL_NAME = ?,
    GUEST_DESCRIPTION = ?,
    GUEST_CAMP_NAME = ?,
    GUEST_CAMP_ADDRESS = ?,
    GUEST_CAMP_DESCRIPTION = ?,

    ARRIVAL_TIME = ?,
    ARRIVAL_METHOD = ?,
    ARRIVAL_STATE = ?,
    ARRIVAL_REASON = ?,
    ARRIVAL_BELONGINGS = ?,

    DEPARTURE_TIME = ?,
    DEPARTURE_METHOD = ?,
    DEPARTURE_STATE = ?,

    RESOURCE_REST = ?,
    RESOURCE_CLOTHES = ?,
    RESOURCE_POGS = ?,
    RESOURCE_FOOD_BEV = ?,
    RESOURCE_OTHER = ?
where
    EVENT = ?
    and NUMBER = ?
`

type UpdateStayParams struct {
	IncidentNumber       sql.NullInt32
	GuestPreferredName   sql.NullString
	GuestLegalName       sql.NullString
	GuestDescription     sql.NullString
	GuestCampName        sql.NullString
	GuestCampAddress     sql.NullString
	GuestCampDescription sql.NullString
	ArrivalTime          sql.NullFloat64
	ArrivalMethod        sql.NullString
	ArrivalState         sql.NullString
	ArrivalReason        sql.NullString
	ArrivalBelongings    sql.NullString
	DepartureTime        sql.NullFloat64
	DepartureMethod      sql.NullString
	DepartureState       sql.NullString
	ResourceRest         sql.NullString
	ResourceClothes      sql.NullString
	ResourcePogs         sql.NullString
	ResourceFoodBev      sql.NullString
	ResourceOther        sql.NullString
	Event                int32
	Number               int32
}

func (q *Queries) UpdateStay(ctx context.Context, db DBTX, arg UpdateStayParams) error {
	_, err := db.ExecContext(ctx, updateStay,
		arg.IncidentNumber,
		arg.GuestPreferredName,
		arg.GuestLegalName,
		arg.GuestDescription,
		arg.GuestCampName,
		arg.GuestCampAddress,
		arg.GuestCampDescription,
		arg.ArrivalTime,
		arg.ArrivalMethod,
		arg.ArrivalState,
		arg.ArrivalReason,
		arg.ArrivalBelongings,
		arg.DepartureTime,
		arg.DepartureMethod,
		arg.DepartureState,
		arg.ResourceRest,
		arg.ResourceClothes,
		arg.ResourcePogs,
		arg.ResourceFoodBev,
		arg.ResourceOther,
		arg.Event,
		arg.Number,
	)
	return err
}
