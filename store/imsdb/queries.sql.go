// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package imsdb

import (
	"context"
	"database/sql"
	"encoding/json"
)

const actionLogs = `-- name: ActionLogs :many
select
    al.id, al.created_at, al.action_type, al.method, al.path, al.referrer, al.user_id, al.user_name, al.position_id, al.position_name, al.client_address, al.http_status, al.duration_micros
from
    ACTION_LOG al
where
    al.CREATED_AT > ?
    and al.CREATED_AT < ?
`

type ActionLogsParams struct {
	MinTime float64
	MaxTime float64
}

type ActionLogsRow struct {
	ActionLog ActionLog
}

func (q *Queries) ActionLogs(ctx context.Context, db DBTX, arg ActionLogsParams) ([]ActionLogsRow, error) {
	rows, err := db.QueryContext(ctx, actionLogs, arg.MinTime, arg.MaxTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ActionLogsRow
	for rows.Next() {
		var i ActionLogsRow
		if err := rows.Scan(
			&i.ActionLog.ID,
			&i.ActionLog.CreatedAt,
			&i.ActionLog.ActionType,
			&i.ActionLog.Method,
			&i.ActionLog.Path,
			&i.ActionLog.Referrer,
			&i.ActionLog.UserID,
			&i.ActionLog.UserName,
			&i.ActionLog.PositionID,
			&i.ActionLog.PositionName,
			&i.ActionLog.ClientAddress,
			&i.ActionLog.HttpStatus,
			&i.ActionLog.DurationMicros,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const addActionLog = `-- name: AddActionLog :execlastid
insert into ACTION_LOG
    (CREATED_AT, ACTION_TYPE, METHOD, PATH, REFERRER, USER_ID, USER_NAME, POSITION_ID, POSITION_NAME, CLIENT_ADDRESS, HTTP_STATUS, DURATION_MICROS)
values
    (?,?,?,?,?,?,?,?,?,?,?,?)
`

type AddActionLogParams struct {
	CreatedAt      float64
	ActionType     string
	Method         sql.NullString
	Path           sql.NullString
	Referrer       sql.NullString
	UserID         sql.NullInt64
	UserName       sql.NullString
	PositionID     sql.NullInt64
	PositionName   sql.NullString
	ClientAddress  sql.NullString
	HttpStatus     sql.NullInt16
	DurationMicros sql.NullInt64
}

func (q *Queries) AddActionLog(ctx context.Context, db DBTX, arg AddActionLogParams) (int64, error) {
	result, err := db.ExecContext(ctx, addActionLog,
		arg.CreatedAt,
		arg.ActionType,
		arg.Method,
		arg.Path,
		arg.Referrer,
		arg.UserID,
		arg.UserName,
		arg.PositionID,
		arg.PositionName,
		arg.ClientAddress,
		arg.HttpStatus,
		arg.DurationMicros,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const addEventAccess = `-- name: AddEventAccess :execlastid
insert into EVENT_ACCESS (EVENT, EXPRESSION, MODE, VALIDITY, EXPIRES)
values (?, ?, ?, ?, ?)
`

type AddEventAccessParams struct {
	Event      int32
	Expression string
	Mode       EventAccessMode
	Validity   EventAccessValidity
	Expires    sql.NullFloat64
}

func (q *Queries) AddEventAccess(ctx context.Context, db DBTX, arg AddEventAccessParams) (int64, error) {
	result, err := db.ExecContext(ctx, addEventAccess,
		arg.Event,
		arg.Expression,
		arg.Mode,
		arg.Validity,
		arg.Expires,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const attachFieldReportToIncident = `-- name: AttachFieldReportToIncident :exec
update FIELD_REPORT
set INCIDENT_NUMBER = ?
where EVENT = ? and NUMBER = ?
`

type AttachFieldReportToIncidentParams struct {
	IncidentNumber sql.NullInt32
	Event          int32
	Number         int32
}

func (q *Queries) AttachFieldReportToIncident(ctx context.Context, db DBTX, arg AttachFieldReportToIncidentParams) error {
	_, err := db.ExecContext(ctx, attachFieldReportToIncident, arg.IncidentNumber, arg.Event, arg.Number)
	return err
}

const attachIncidentTypeToIncident = `-- name: AttachIncidentTypeToIncident :exec
insert into INCIDENT__INCIDENT_TYPE (
    EVENT, INCIDENT_NUMBER, INCIDENT_TYPE
) values (
     ?, ?, ?
 )
`

type AttachIncidentTypeToIncidentParams struct {
	Event          int32
	IncidentNumber int32
	IncidentType   int32
}

func (q *Queries) AttachIncidentTypeToIncident(ctx context.Context, db DBTX, arg AttachIncidentTypeToIncidentParams) error {
	_, err := db.ExecContext(ctx, attachIncidentTypeToIncident, arg.Event, arg.IncidentNumber, arg.IncidentType)
	return err
}

const attachRangerHandleToIncident = `-- name: AttachRangerHandleToIncident :exec
insert into INCIDENT__RANGER (EVENT, INCIDENT_NUMBER, RANGER_HANDLE)
values (?, ?, ?)
`

type AttachRangerHandleToIncidentParams struct {
	Event          int32
	IncidentNumber int32
	RangerHandle   string
}

func (q *Queries) AttachRangerHandleToIncident(ctx context.Context, db DBTX, arg AttachRangerHandleToIncidentParams) error {
	_, err := db.ExecContext(ctx, attachRangerHandleToIncident, arg.Event, arg.IncidentNumber, arg.RangerHandle)
	return err
}

const attachReportEntryToFieldReport = `-- name: AttachReportEntryToFieldReport :exec
insert into FIELD_REPORT__REPORT_ENTRY (
    EVENT, FIELD_REPORT_NUMBER, REPORT_ENTRY
) values (
    ?, ?, ?
)
`

type AttachReportEntryToFieldReportParams struct {
	Event             int32
	FieldReportNumber int32
	ReportEntry       int32
}

func (q *Queries) AttachReportEntryToFieldReport(ctx context.Context, db DBTX, arg AttachReportEntryToFieldReportParams) error {
	_, err := db.ExecContext(ctx, attachReportEntryToFieldReport, arg.Event, arg.FieldReportNumber, arg.ReportEntry)
	return err
}

const attachReportEntryToIncident = `-- name: AttachReportEntryToIncident :exec
insert into INCIDENT__REPORT_ENTRY (
    EVENT, INCIDENT_NUMBER, REPORT_ENTRY
) values (
    ?, ?, ?
)
`

type AttachReportEntryToIncidentParams struct {
	Event          int32
	IncidentNumber int32
	ReportEntry    int32
}

func (q *Queries) AttachReportEntryToIncident(ctx context.Context, db DBTX, arg AttachReportEntryToIncidentParams) error {
	_, err := db.ExecContext(ctx, attachReportEntryToIncident, arg.Event, arg.IncidentNumber, arg.ReportEntry)
	return err
}

const clearEventAccessForExpression = `-- name: ClearEventAccessForExpression :exec
delete from EVENT_ACCESS
where EVENT = ? and EXPRESSION = ?
`

type ClearEventAccessForExpressionParams struct {
	Event      int32
	Expression string
}

func (q *Queries) ClearEventAccessForExpression(ctx context.Context, db DBTX, arg ClearEventAccessForExpressionParams) error {
	_, err := db.ExecContext(ctx, clearEventAccessForExpression, arg.Event, arg.Expression)
	return err
}

const clearEventAccessForMode = `-- name: ClearEventAccessForMode :exec
delete from EVENT_ACCESS
where EVENT = ? and MODE = ?
`

type ClearEventAccessForModeParams struct {
	Event int32
	Mode  EventAccessMode
}

func (q *Queries) ClearEventAccessForMode(ctx context.Context, db DBTX, arg ClearEventAccessForModeParams) error {
	_, err := db.ExecContext(ctx, clearEventAccessForMode, arg.Event, arg.Mode)
	return err
}

const concentricStreets = `-- name: ConcentricStreets :many
select cs.event, cs.id, cs.name
from CONCENTRIC_STREET cs
where cs.EVENT = ?
`

type ConcentricStreetsRow struct {
	ConcentricStreet ConcentricStreet
}

func (q *Queries) ConcentricStreets(ctx context.Context, db DBTX, event int32) ([]ConcentricStreetsRow, error) {
	rows, err := db.QueryContext(ctx, concentricStreets, event)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ConcentricStreetsRow
	for rows.Next() {
		var i ConcentricStreetsRow
		if err := rows.Scan(&i.ConcentricStreet.Event, &i.ConcentricStreet.ID, &i.ConcentricStreet.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createConcentricStreet = `-- name: CreateConcentricStreet :exec
insert into CONCENTRIC_STREET (EVENT, ID, NAME)
values (?, ?, ?)
`

type CreateConcentricStreetParams struct {
	Event int32
	ID    string
	Name  string
}

func (q *Queries) CreateConcentricStreet(ctx context.Context, db DBTX, arg CreateConcentricStreetParams) error {
	_, err := db.ExecContext(ctx, createConcentricStreet, arg.Event, arg.ID, arg.Name)
	return err
}

const createDestination = `-- name: CreateDestination :exec
insert into DESTINATION
    (EVENT, NUMBER, TYPE, NAME, LOCATION_STRING, EXTERNAL_DATA)
values
    (?,?,?,?,?,?)
`

type CreateDestinationParams struct {
	Event          int32
	Number         int32
	Type           DestinationType
	Name           string
	LocationString string
	ExternalData   json.RawMessage
}

func (q *Queries) CreateDestination(ctx context.Context, db DBTX, arg CreateDestinationParams) error {
	_, err := db.ExecContext(ctx, createDestination,
		arg.Event,
		arg.Number,
		arg.Type,
		arg.Name,
		arg.LocationString,
		arg.ExternalData,
	)
	return err
}

const createEvent = `-- name: CreateEvent :execlastid
insert into EVENT (NAME, IS_GROUP) values (?, ?)
`

type CreateEventParams struct {
	Name    string
	IsGroup bool
}

func (q *Queries) CreateEvent(ctx context.Context, db DBTX, arg CreateEventParams) (int64, error) {
	result, err := db.ExecContext(ctx, createEvent, arg.Name, arg.IsGroup)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createFieldReport = `-- name: CreateFieldReport :exec
insert into FIELD_REPORT (
    EVENT, NUMBER, CREATED, SUMMARY, INCIDENT_NUMBER
)
values (?, ?, ?, ?, ?)
`

type CreateFieldReportParams struct {
	Event          int32
	Number         int32
	Created        float64
	Summary        sql.NullString
	IncidentNumber sql.NullInt32
}

func (q *Queries) CreateFieldReport(ctx context.Context, db DBTX, arg CreateFieldReportParams) error {
	_, err := db.ExecContext(ctx, createFieldReport,
		arg.Event,
		arg.Number,
		arg.Created,
		arg.Summary,
		arg.IncidentNumber,
	)
	return err
}

const createIncident = `-- name: CreateIncident :execlastid
insert into INCIDENT (
    EVENT,
    NUMBER,
    CREATED,
    PRIORITY,
    STATE,
    STARTED
)
values (
   ?,?,?,?,?,?
)
`

type CreateIncidentParams struct {
	Event    int32
	Number   int32
	Created  float64
	Priority int8
	State    IncidentState
	Started  float64
}

func (q *Queries) CreateIncident(ctx context.Context, db DBTX, arg CreateIncidentParams) (int64, error) {
	result, err := db.ExecContext(ctx, createIncident,
		arg.Event,
		arg.Number,
		arg.Created,
		arg.Priority,
		arg.State,
		arg.Started,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createIncidentType = `-- name: CreateIncidentType :execlastid
insert into INCIDENT_TYPE (NAME, HIDDEN)
values (?, ?)
`

type CreateIncidentTypeParams struct {
	Name   string
	Hidden bool
}

func (q *Queries) CreateIncidentType(ctx context.Context, db DBTX, arg CreateIncidentTypeParams) (int64, error) {
	result, err := db.ExecContext(ctx, createIncidentType, arg.Name, arg.Hidden)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const createReportEntry = `-- name: CreateReportEntry :execlastid
insert into REPORT_ENTRY (
    AUTHOR, TEXT, CREATED, ` + "`" + `GENERATED` + "`" + `, STRICKEN,
    ATTACHED_FILE, ATTACHED_FILE_ORIGINAL_NAME, ATTACHED_FILE_MEDIA_TYPE
) values (
   ?, ?, ?, ?, ?, ?, ?, ?
)
`

type CreateReportEntryParams struct {
	Author                   string
	Text                     string
	Created                  float64
	Generated                bool
	Stricken                 bool
	AttachedFile             sql.NullString
	AttachedFileOriginalName sql.NullString
	AttachedFileMediaType    sql.NullString
}

func (q *Queries) CreateReportEntry(ctx context.Context, db DBTX, arg CreateReportEntryParams) (int64, error) {
	result, err := db.ExecContext(ctx, createReportEntry,
		arg.Author,
		arg.Text,
		arg.Created,
		arg.Generated,
		arg.Stricken,
		arg.AttachedFile,
		arg.AttachedFileOriginalName,
		arg.AttachedFileMediaType,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const destinations = `-- name: Destinations :many
select
    EVENT,
    TYPE,
    NUMBER,
    NAME,
    LOCATION_STRING,
    if(?, '', EXTERNAL_DATA) as EXTERNAL_DATA
from
    DESTINATION d
where
    EVENT = ?
`

type DestinationsParams struct {
	ExcludeExternalData interface{}
	Event               int32
}

type DestinationsRow struct {
	Event          int32
	Type           DestinationType
	Number         int32
	Name           string
	LocationString string
	ExternalData   interface{}
}

func (q *Queries) Destinations(ctx context.Context, db DBTX, arg DestinationsParams) ([]DestinationsRow, error) {
	rows, err := db.QueryContext(ctx, destinations, arg.ExcludeExternalData, arg.Event)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DestinationsRow
	for rows.Next() {
		var i DestinationsRow
		if err := rows.Scan(
			&i.Event,
			&i.Type,
			&i.Number,
			&i.Name,
			&i.LocationString,
			&i.ExternalData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const detachIncidentTypeFromIncident = `-- name: DetachIncidentTypeFromIncident :exec
delete from INCIDENT__INCIDENT_TYPE
where
    EVENT = ?
    and INCIDENT_NUMBER = ?
    and INCIDENT_TYPE = ?
`

type DetachIncidentTypeFromIncidentParams struct {
	Event          int32
	IncidentNumber int32
	IncidentType   int32
}

func (q *Queries) DetachIncidentTypeFromIncident(ctx context.Context, db DBTX, arg DetachIncidentTypeFromIncidentParams) error {
	_, err := db.ExecContext(ctx, detachIncidentTypeFromIncident, arg.Event, arg.IncidentNumber, arg.IncidentType)
	return err
}

const detachRangerHandleFromIncident = `-- name: DetachRangerHandleFromIncident :exec
delete from INCIDENT__RANGER
where
    EVENT = ?
    and INCIDENT_NUMBER = ?
    and RANGER_HANDLE = ?
`

type DetachRangerHandleFromIncidentParams struct {
	Event          int32
	IncidentNumber int32
	RangerHandle   string
}

func (q *Queries) DetachRangerHandleFromIncident(ctx context.Context, db DBTX, arg DetachRangerHandleFromIncidentParams) error {
	_, err := db.ExecContext(ctx, detachRangerHandleFromIncident, arg.Event, arg.IncidentNumber, arg.RangerHandle)
	return err
}

const event = `-- name: Event :one
select e.id, e.name, e.is_group, e.parent_group from EVENT e where ID = ?
`

type EventRow struct {
	Event Event
}

func (q *Queries) Event(ctx context.Context, db DBTX, id int32) (EventRow, error) {
	row := db.QueryRowContext(ctx, event, id)
	var i EventRow
	err := row.Scan(
		&i.Event.ID,
		&i.Event.Name,
		&i.Event.IsGroup,
		&i.Event.ParentGroup,
	)
	return i, err
}

const eventAccessAll = `-- name: EventAccessAll :many
select ea.id, ea.event, ea.expression, ea.mode, ea.validity, ea.expires
from EVENT_ACCESS ea
`

type EventAccessAllRow struct {
	EventAccess EventAccess
}

func (q *Queries) EventAccessAll(ctx context.Context, db DBTX) ([]EventAccessAllRow, error) {
	rows, err := db.QueryContext(ctx, eventAccessAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventAccessAllRow
	for rows.Next() {
		var i EventAccessAllRow
		if err := rows.Scan(
			&i.EventAccess.ID,
			&i.EventAccess.Event,
			&i.EventAccess.Expression,
			&i.EventAccess.Mode,
			&i.EventAccess.Validity,
			&i.EventAccess.Expires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const eventAndParentAccess = `-- name: EventAndParentAccess :many
select ea.id, ea.event, ea.expression, ea.mode, ea.validity, ea.expires
from EVENT_ACCESS ea
where ea.EVENT = ?
union all
select ea.id, ea.event, ea.expression, ea.mode, ea.validity, ea.expires
from ` + "`" + `EVENT` + "`" + ` e
    join EVENT_ACCESS ea
        on e.PARENT_GROUP = ea.EVENT
where e.ID = ?
    and e.PARENT_GROUP is not null
`

type EventAndParentAccessParams struct {
	EventID int32
}

type EventAndParentAccessRow struct {
	EventAccess EventAccess
}

func (q *Queries) EventAndParentAccess(ctx context.Context, db DBTX, arg EventAndParentAccessParams) ([]EventAndParentAccessRow, error) {
	rows, err := db.QueryContext(ctx, eventAndParentAccess, arg.EventID, arg.EventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventAndParentAccessRow
	for rows.Next() {
		var i EventAndParentAccessRow
		if err := rows.Scan(
			&i.EventAccess.ID,
			&i.EventAccess.Event,
			&i.EventAccess.Expression,
			&i.EventAccess.Mode,
			&i.EventAccess.Validity,
			&i.EventAccess.Expires,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const events = `-- name: Events :many
select e.id, e.name, e.is_group, e.parent_group from EVENT e
`

type EventsRow struct {
	Event Event
}

func (q *Queries) Events(ctx context.Context, db DBTX) ([]EventsRow, error) {
	rows, err := db.QueryContext(ctx, events)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventsRow
	for rows.Next() {
		var i EventsRow
		if err := rows.Scan(
			&i.Event.ID,
			&i.Event.Name,
			&i.Event.IsGroup,
			&i.Event.ParentGroup,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fieldReport = `-- name: FieldReport :one
select fr.event, fr.number, fr.created, fr.summary, fr.incident_number
from FIELD_REPORT fr
where fr.EVENT = ?
    and fr.NUMBER = ?
`

type FieldReportParams struct {
	Event  int32
	Number int32
}

type FieldReportRow struct {
	FieldReport FieldReport
}

func (q *Queries) FieldReport(ctx context.Context, db DBTX, arg FieldReportParams) (FieldReportRow, error) {
	row := db.QueryRowContext(ctx, fieldReport, arg.Event, arg.Number)
	var i FieldReportRow
	err := row.Scan(
		&i.FieldReport.Event,
		&i.FieldReport.Number,
		&i.FieldReport.Created,
		&i.FieldReport.Summary,
		&i.FieldReport.IncidentNumber,
	)
	return i, err
}

const fieldReport_ReportEntries = `-- name: FieldReport_ReportEntries :many
select
    re.id, re.author, re.text, re.created, re.` + "`" + `generated` + "`" + `, re.stricken, re.attached_file, re.attached_file_original_name, re.attached_file_media_type
from
    FIELD_REPORT__REPORT_ENTRY irre
        join REPORT_ENTRY re
             on irre.REPORT_ENTRY = re.ID
where
    irre.EVENT = ?
    and irre.FIELD_REPORT_NUMBER = ?
`

type FieldReport_ReportEntriesParams struct {
	Event             int32
	FieldReportNumber int32
}

type FieldReport_ReportEntriesRow struct {
	ReportEntry ReportEntry
}

func (q *Queries) FieldReport_ReportEntries(ctx context.Context, db DBTX, arg FieldReport_ReportEntriesParams) ([]FieldReport_ReportEntriesRow, error) {
	rows, err := db.QueryContext(ctx, fieldReport_ReportEntries, arg.Event, arg.FieldReportNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FieldReport_ReportEntriesRow
	for rows.Next() {
		var i FieldReport_ReportEntriesRow
		if err := rows.Scan(
			&i.ReportEntry.ID,
			&i.ReportEntry.Author,
			&i.ReportEntry.Text,
			&i.ReportEntry.Created,
			&i.ReportEntry.Generated,
			&i.ReportEntry.Stricken,
			&i.ReportEntry.AttachedFile,
			&i.ReportEntry.AttachedFileOriginalName,
			&i.ReportEntry.AttachedFileMediaType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fieldReports = `-- name: FieldReports :many
select fr.event, fr.number, fr.created, fr.summary, fr.incident_number
from FIELD_REPORT fr
where fr.EVENT = ?
`

type FieldReportsRow struct {
	FieldReport FieldReport
}

func (q *Queries) FieldReports(ctx context.Context, db DBTX, event int32) ([]FieldReportsRow, error) {
	rows, err := db.QueryContext(ctx, fieldReports, event)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FieldReportsRow
	for rows.Next() {
		var i FieldReportsRow
		if err := rows.Scan(
			&i.FieldReport.Event,
			&i.FieldReport.Number,
			&i.FieldReport.Created,
			&i.FieldReport.Summary,
			&i.FieldReport.IncidentNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fieldReports_ReportEntries = `-- name: FieldReports_ReportEntries :many
select
    irre.FIELD_REPORT_NUMBER,
    re.id, re.author, re.text, re.created, re.` + "`" + `generated` + "`" + `, re.stricken, re.attached_file, re.attached_file_original_name, re.attached_file_media_type
from
    FIELD_REPORT__REPORT_ENTRY irre
        join REPORT_ENTRY re
             on irre.REPORT_ENTRY = re.ID
where
    irre.EVENT = ?
    and re.GENERATED <= ?
`

type FieldReports_ReportEntriesParams struct {
	Event     int32
	Generated bool
}

type FieldReports_ReportEntriesRow struct {
	FieldReportNumber int32
	ReportEntry       ReportEntry
}

func (q *Queries) FieldReports_ReportEntries(ctx context.Context, db DBTX, arg FieldReports_ReportEntriesParams) ([]FieldReports_ReportEntriesRow, error) {
	rows, err := db.QueryContext(ctx, fieldReports_ReportEntries, arg.Event, arg.Generated)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FieldReports_ReportEntriesRow
	for rows.Next() {
		var i FieldReports_ReportEntriesRow
		if err := rows.Scan(
			&i.FieldReportNumber,
			&i.ReportEntry.ID,
			&i.ReportEntry.Author,
			&i.ReportEntry.Text,
			&i.ReportEntry.Created,
			&i.ReportEntry.Generated,
			&i.ReportEntry.Stricken,
			&i.ReportEntry.AttachedFile,
			&i.ReportEntry.AttachedFileOriginalName,
			&i.ReportEntry.AttachedFileMediaType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incident = `-- name: Incident :one
select
    i.event, i.number, i.created, i.priority, i.state, i.started, i.closed, i.summary, i.location_name, i.location_address, i.location_concentric, i.location_radial_hour, i.location_radial_minute, i.location_description,
    (
        select coalesce(json_arrayagg(iit.INCIDENT_TYPE), "[]")
        from INCIDENT__INCIDENT_TYPE iit
        where i.EVENT = iit.EVENT
          and i.NUMBER = iit.INCIDENT_NUMBER
    ) as INCIDENT_TYPE_IDS,
    (
        select coalesce(json_arrayagg(irep.NUMBER), "[]")
        from FIELD_REPORT irep
        where i.EVENT = irep.EVENT
          and i.NUMBER = irep.INCIDENT_NUMBER
    ) as FIELD_REPORT_NUMBERS,
    (
        select coalesce(json_arrayagg(ir.RANGER_HANDLE), "[]")
        from INCIDENT__RANGER ir
        where i.EVENT = ir.EVENT
            and i.NUMBER = ir.INCIDENT_NUMBER
    ) as RANGER_HANDLES
from INCIDENT i
where i.EVENT = ?
    and i.NUMBER = ?
`

type IncidentParams struct {
	Event  int32
	Number int32
}

type IncidentRow struct {
	Incident           Incident
	IncidentTypeIds    interface{}
	FieldReportNumbers interface{}
	RangerHandles      interface{}
}

func (q *Queries) Incident(ctx context.Context, db DBTX, arg IncidentParams) (IncidentRow, error) {
	row := db.QueryRowContext(ctx, incident, arg.Event, arg.Number)
	var i IncidentRow
	err := row.Scan(
		&i.Incident.Event,
		&i.Incident.Number,
		&i.Incident.Created,
		&i.Incident.Priority,
		&i.Incident.State,
		&i.Incident.Started,
		&i.Incident.Closed,
		&i.Incident.Summary,
		&i.Incident.LocationName,
		&i.Incident.LocationAddress,
		&i.Incident.LocationConcentric,
		&i.Incident.LocationRadialHour,
		&i.Incident.LocationRadialMinute,
		&i.Incident.LocationDescription,
		&i.IncidentTypeIds,
		&i.FieldReportNumbers,
		&i.RangerHandles,
	)
	return i, err
}

const incidentType = `-- name: IncidentType :one
select it.id, it.name, it.hidden, it.description
from INCIDENT_TYPE it
where it.ID = ?
`

type IncidentTypeRow struct {
	IncidentType IncidentType
}

func (q *Queries) IncidentType(ctx context.Context, db DBTX, id int32) (IncidentTypeRow, error) {
	row := db.QueryRowContext(ctx, incidentType, id)
	var i IncidentTypeRow
	err := row.Scan(
		&i.IncidentType.ID,
		&i.IncidentType.Name,
		&i.IncidentType.Hidden,
		&i.IncidentType.Description,
	)
	return i, err
}

const incidentTypes = `-- name: IncidentTypes :many
select it.id, it.name, it.hidden, it.description
from INCIDENT_TYPE it
`

type IncidentTypesRow struct {
	IncidentType IncidentType
}

func (q *Queries) IncidentTypes(ctx context.Context, db DBTX) ([]IncidentTypesRow, error) {
	rows, err := db.QueryContext(ctx, incidentTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IncidentTypesRow
	for rows.Next() {
		var i IncidentTypesRow
		if err := rows.Scan(
			&i.IncidentType.ID,
			&i.IncidentType.Name,
			&i.IncidentType.Hidden,
			&i.IncidentType.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incident_LinkedIncidents = `-- name: Incident_LinkedIncidents :many
select
    ili.EVENT_2 as LINKED_EVENT,
    e.NAME as LINKED_EVENT_NAME,
    ili.INCIDENT_NUMBER_2 as LINKED_INCIDENT,
    i2.SUMMARY as LINKED_INCIDENT_SUMMARY
from
    INCIDENT__LINKED_INCIDENT ili
    join ` + "`" + `EVENT` + "`" + ` e
        on e.ID = ili.EVENT_2
    join INCIDENT i2
        on i2.EVENT = ili.EVENT_2
            and i2.NUMBER = ili.INCIDENT_NUMBER_2
where
    ili.EVENT_1 = ?
    and ili.INCIDENT_NUMBER_1 = ?
`

type Incident_LinkedIncidentsParams struct {
	Event1          int32
	IncidentNumber1 int32
}

type Incident_LinkedIncidentsRow struct {
	LinkedEvent           int32
	LinkedEventName       string
	LinkedIncident        int32
	LinkedIncidentSummary sql.NullString
}

func (q *Queries) Incident_LinkedIncidents(ctx context.Context, db DBTX, arg Incident_LinkedIncidentsParams) ([]Incident_LinkedIncidentsRow, error) {
	rows, err := db.QueryContext(ctx, incident_LinkedIncidents, arg.Event1, arg.IncidentNumber1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Incident_LinkedIncidentsRow
	for rows.Next() {
		var i Incident_LinkedIncidentsRow
		if err := rows.Scan(
			&i.LinkedEvent,
			&i.LinkedEventName,
			&i.LinkedIncident,
			&i.LinkedIncidentSummary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incident_ReportEntries = `-- name: Incident_ReportEntries :many
select
    ire.INCIDENT_NUMBER,
    re.id, re.author, re.text, re.created, re.` + "`" + `generated` + "`" + `, re.stricken, re.attached_file, re.attached_file_original_name, re.attached_file_media_type
from
    INCIDENT__REPORT_ENTRY ire
        join REPORT_ENTRY re
             on re.ID = ire.REPORT_ENTRY
where
    ire.EVENT = ?
    and ire.INCIDENT_NUMBER = ?
`

type Incident_ReportEntriesParams struct {
	Event          int32
	IncidentNumber int32
}

type Incident_ReportEntriesRow struct {
	IncidentNumber int32
	ReportEntry    ReportEntry
}

func (q *Queries) Incident_ReportEntries(ctx context.Context, db DBTX, arg Incident_ReportEntriesParams) ([]Incident_ReportEntriesRow, error) {
	rows, err := db.QueryContext(ctx, incident_ReportEntries, arg.Event, arg.IncidentNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Incident_ReportEntriesRow
	for rows.Next() {
		var i Incident_ReportEntriesRow
		if err := rows.Scan(
			&i.IncidentNumber,
			&i.ReportEntry.ID,
			&i.ReportEntry.Author,
			&i.ReportEntry.Text,
			&i.ReportEntry.Created,
			&i.ReportEntry.Generated,
			&i.ReportEntry.Stricken,
			&i.ReportEntry.AttachedFile,
			&i.ReportEntry.AttachedFileOriginalName,
			&i.ReportEntry.AttachedFileMediaType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incidents = `-- name: Incidents :many
select
    i.event, i.number, i.created, i.priority, i.state, i.started, i.closed, i.summary, i.location_name, i.location_address, i.location_concentric, i.location_radial_hour, i.location_radial_minute, i.location_description,
    (
        select coalesce(json_arrayagg(iit.INCIDENT_TYPE), "[]")
        from INCIDENT__INCIDENT_TYPE iit
        where i.EVENT = iit.EVENT
            and i.NUMBER = iit.INCIDENT_NUMBER
    ) as INCIDENT_TYPE_IDS,
    (
        select coalesce(json_arrayagg(irep.NUMBER), "[]")
        from FIELD_REPORT irep
        where i.EVENT = irep.EVENT
            and i.NUMBER = irep.INCIDENT_NUMBER
    ) as FIELD_REPORT_NUMBERS,
    (
        select coalesce(json_arrayagg(ir.RANGER_HANDLE), "[]")
        from INCIDENT__RANGER ir
        where i.EVENT = ir.EVENT
            and i.NUMBER = ir.INCIDENT_NUMBER
    ) as RANGER_HANDLES
from
    INCIDENT i
where
    i.EVENT = ?
group by
    i.NUMBER
`

type IncidentsRow struct {
	Incident           Incident
	IncidentTypeIds    interface{}
	FieldReportNumbers interface{}
	RangerHandles      interface{}
}

func (q *Queries) Incidents(ctx context.Context, db DBTX, event int32) ([]IncidentsRow, error) {
	rows, err := db.QueryContext(ctx, incidents, event)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []IncidentsRow
	for rows.Next() {
		var i IncidentsRow
		if err := rows.Scan(
			&i.Incident.Event,
			&i.Incident.Number,
			&i.Incident.Created,
			&i.Incident.Priority,
			&i.Incident.State,
			&i.Incident.Started,
			&i.Incident.Closed,
			&i.Incident.Summary,
			&i.Incident.LocationName,
			&i.Incident.LocationAddress,
			&i.Incident.LocationConcentric,
			&i.Incident.LocationRadialHour,
			&i.Incident.LocationRadialMinute,
			&i.Incident.LocationDescription,
			&i.IncidentTypeIds,
			&i.FieldReportNumbers,
			&i.RangerHandles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const incidents_ReportEntries = `-- name: Incidents_ReportEntries :many
select
    ire.INCIDENT_NUMBER,
    re.id, re.author, re.text, re.created, re.` + "`" + `generated` + "`" + `, re.stricken, re.attached_file, re.attached_file_original_name, re.attached_file_media_type
from
    INCIDENT__REPORT_ENTRY ire
        join REPORT_ENTRY re
             on re.ID = ire.REPORT_ENTRY
where
    ire.EVENT = ?
    and re.GENERATED <= ?
`

type Incidents_ReportEntriesParams struct {
	Event     int32
	Generated bool
}

type Incidents_ReportEntriesRow struct {
	IncidentNumber int32
	ReportEntry    ReportEntry
}

func (q *Queries) Incidents_ReportEntries(ctx context.Context, db DBTX, arg Incidents_ReportEntriesParams) ([]Incidents_ReportEntriesRow, error) {
	rows, err := db.QueryContext(ctx, incidents_ReportEntries, arg.Event, arg.Generated)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Incidents_ReportEntriesRow
	for rows.Next() {
		var i Incidents_ReportEntriesRow
		if err := rows.Scan(
			&i.IncidentNumber,
			&i.ReportEntry.ID,
			&i.ReportEntry.Author,
			&i.ReportEntry.Text,
			&i.ReportEntry.Created,
			&i.ReportEntry.Generated,
			&i.ReportEntry.Stricken,
			&i.ReportEntry.AttachedFile,
			&i.ReportEntry.AttachedFileOriginalName,
			&i.ReportEntry.AttachedFileMediaType,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkIncidents = `-- name: LinkIncidents :exec
insert into INCIDENT__LINKED_INCIDENT
    (EVENT_1, INCIDENT_NUMBER_1, EVENT_2, INCIDENT_NUMBER_2)
values
    (?, ?, ?, ?)
`

type LinkIncidentsParams struct {
	Event1          int32
	IncidentNumber1 int32
	Event2          int32
	IncidentNumber2 int32
}

func (q *Queries) LinkIncidents(ctx context.Context, db DBTX, arg LinkIncidentsParams) error {
	_, err := db.ExecContext(ctx, linkIncidents,
		arg.Event1,
		arg.IncidentNumber1,
		arg.Event2,
		arg.IncidentNumber2,
	)
	return err
}

const nextFieldReportNumber = `-- name: NextFieldReportNumber :one
select NUMBER + 1 as NEXT_ID
from FIELD_REPORT
where EVENT = ?
union
select 1
order by 1 desc
limit 1
`

// This doesn't use "MAX" because sqlc can't figure out the type for aggregations :(.
func (q *Queries) NextFieldReportNumber(ctx context.Context, db DBTX, event int32) (int32, error) {
	row := db.QueryRowContext(ctx, nextFieldReportNumber, event)
	var next_id int32
	err := row.Scan(&next_id)
	return next_id, err
}

const nextIncidentNumber = `-- name: NextIncidentNumber :one
select NUMBER + 1 as NEXT_ID
from INCIDENT
where EVENT = ?
union
select 1
order by 1 desc
limit 1
`

// This doesn't use "MAX" because sqlc can't figure out the type for aggregations :(.
func (q *Queries) NextIncidentNumber(ctx context.Context, db DBTX, event int32) (int32, error) {
	row := db.QueryRowContext(ctx, nextIncidentNumber, event)
	var next_id int32
	err := row.Scan(&next_id)
	return next_id, err
}

const queryEventID = `-- name: QueryEventID :one
select e.id, e.name, e.is_group, e.parent_group from EVENT e where e.NAME = ?
`

type QueryEventIDRow struct {
	Event Event
}

func (q *Queries) QueryEventID(ctx context.Context, db DBTX, name string) (QueryEventIDRow, error) {
	row := db.QueryRowContext(ctx, queryEventID, name)
	var i QueryEventIDRow
	err := row.Scan(
		&i.Event.ID,
		&i.Event.Name,
		&i.Event.IsGroup,
		&i.Event.ParentGroup,
	)
	return i, err
}

const removeDestinations = `-- name: RemoveDestinations :exec
delete from
    DESTINATION
where EVENT = ?
    and TYPE = ?
`

type RemoveDestinationsParams struct {
	Event int32
	Type  DestinationType
}

func (q *Queries) RemoveDestinations(ctx context.Context, db DBTX, arg RemoveDestinationsParams) error {
	_, err := db.ExecContext(ctx, removeDestinations, arg.Event, arg.Type)
	return err
}

const schemaVersion = `-- name: SchemaVersion :one
select VERSION from SCHEMA_INFO
`

func (q *Queries) SchemaVersion(ctx context.Context, db DBTX) (int16, error) {
	row := db.QueryRowContext(ctx, schemaVersion)
	var version int16
	err := row.Scan(&version)
	return version, err
}

const setFieldReportReportEntryStricken = `-- name: SetFieldReportReportEntryStricken :exec
update REPORT_ENTRY
set STRICKEN = ?
where ID IN (
    select REPORT_ENTRY
    from FIELD_REPORT__REPORT_ENTRY
    where EVENT = ?
      and FIELD_REPORT_NUMBER = ?
      and REPORT_ENTRY = ?
)
`

type SetFieldReportReportEntryStrickenParams struct {
	Stricken          bool
	Event             int32
	FieldReportNumber int32
	ReportEntry       int32
}

func (q *Queries) SetFieldReportReportEntryStricken(ctx context.Context, db DBTX, arg SetFieldReportReportEntryStrickenParams) error {
	_, err := db.ExecContext(ctx, setFieldReportReportEntryStricken,
		arg.Stricken,
		arg.Event,
		arg.FieldReportNumber,
		arg.ReportEntry,
	)
	return err
}

const setIncidentReportEntryStricken = `-- name: SetIncidentReportEntryStricken :exec

update REPORT_ENTRY
set STRICKEN = ?
where ID IN (
    select REPORT_ENTRY
    from INCIDENT__REPORT_ENTRY
    where EVENT = ?
        and INCIDENT_NUMBER = ?
        and REPORT_ENTRY = ?
)
`

type SetIncidentReportEntryStrickenParams struct {
	Stricken       bool
	Event          int32
	IncidentNumber int32
	ReportEntry    int32
}

// The "stricken" queries seem bloated at first blush, because the whole
// "where ID in (..." could just be "where ID =". What it's doing though is
// ensuring that the provided eventID and incidentNumber actually align with
// the reportEntryID in question, and that's important for authorization purposes.
func (q *Queries) SetIncidentReportEntryStricken(ctx context.Context, db DBTX, arg SetIncidentReportEntryStrickenParams) error {
	_, err := db.ExecContext(ctx, setIncidentReportEntryStricken,
		arg.Stricken,
		arg.Event,
		arg.IncidentNumber,
		arg.ReportEntry,
	)
	return err
}

const unlinkIncidents = `-- name: UnlinkIncidents :exec
delete from INCIDENT__LINKED_INCIDENT
where
    EVENT_1 = ?
    and INCIDENT_NUMBER_1 = ?
    and EVENT_2 = ?
    and INCIDENT_NUMBER_2 = ?
`

type UnlinkIncidentsParams struct {
	Event1          int32
	IncidentNumber1 int32
	Event2          int32
	IncidentNumber2 int32
}

func (q *Queries) UnlinkIncidents(ctx context.Context, db DBTX, arg UnlinkIncidentsParams) error {
	_, err := db.ExecContext(ctx, unlinkIncidents,
		arg.Event1,
		arg.IncidentNumber1,
		arg.Event2,
		arg.IncidentNumber2,
	)
	return err
}

const updateEventParent = `-- name: UpdateEventParent :exec
update ` + "`" + `EVENT` + "`" + `
set PARENT_GROUP = ?
where ID = ? and not IS_GROUP
`

type UpdateEventParentParams struct {
	ParentGroup sql.NullInt32
	ID          int32
}

func (q *Queries) UpdateEventParent(ctx context.Context, db DBTX, arg UpdateEventParentParams) error {
	_, err := db.ExecContext(ctx, updateEventParent, arg.ParentGroup, arg.ID)
	return err
}

const updateFieldReport = `-- name: UpdateFieldReport :exec
update FIELD_REPORT
set SUMMARY = ?, INCIDENT_NUMBER = ?
where EVENT = ? and NUMBER = ?
`

type UpdateFieldReportParams struct {
	Summary        sql.NullString
	IncidentNumber sql.NullInt32
	Event          int32
	Number         int32
}

func (q *Queries) UpdateFieldReport(ctx context.Context, db DBTX, arg UpdateFieldReportParams) error {
	_, err := db.ExecContext(ctx, updateFieldReport,
		arg.Summary,
		arg.IncidentNumber,
		arg.Event,
		arg.Number,
	)
	return err
}

const updateIncident = `-- name: UpdateIncident :exec
update INCIDENT set
    -- CREATED should be immutable, so it's not present in this UPDATE query
    PRIORITY = ?,
    STATE = ?,
    STARTED = ?,
    CLOSED = ?,
    SUMMARY = ?,
    LOCATION_NAME = ?,
    LOCATION_ADDRESS = ?,
    LOCATION_CONCENTRIC = ?,
    LOCATION_RADIAL_HOUR = ?,
    LOCATION_RADIAL_MINUTE = ?,
    LOCATION_DESCRIPTION = ?
where
    EVENT = ?
    and NUMBER = ?
`

type UpdateIncidentParams struct {
	Priority             int8
	State                IncidentState
	Started              float64
	Closed               sql.NullFloat64
	Summary              sql.NullString
	LocationName         sql.NullString
	LocationAddress      sql.NullString
	LocationConcentric   sql.NullString
	LocationRadialHour   sql.NullInt16
	LocationRadialMinute sql.NullInt16
	LocationDescription  sql.NullString
	Event                int32
	Number               int32
}

func (q *Queries) UpdateIncident(ctx context.Context, db DBTX, arg UpdateIncidentParams) error {
	_, err := db.ExecContext(ctx, updateIncident,
		arg.Priority,
		arg.State,
		arg.Started,
		arg.Closed,
		arg.Summary,
		arg.LocationName,
		arg.LocationAddress,
		arg.LocationConcentric,
		arg.LocationRadialHour,
		arg.LocationRadialMinute,
		arg.LocationDescription,
		arg.Event,
		arg.Number,
	)
	return err
}

const updateIncidentType = `-- name: UpdateIncidentType :exec
update INCIDENT_TYPE
set HIDDEN = ?,
    NAME = ?,
    DESCRIPTION = ?
where ID = ?
`

type UpdateIncidentTypeParams struct {
	Hidden      bool
	Name        string
	Description sql.NullString
	ID          int32
}

func (q *Queries) UpdateIncidentType(ctx context.Context, db DBTX, arg UpdateIncidentTypeParams) error {
	_, err := db.ExecContext(ctx, updateIncidentType,
		arg.Hidden,
		arg.Name,
		arg.Description,
		arg.ID,
	)
	return err
}
